<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Sagittarius">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="Sagittarius">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Sagittarius</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sagittarius</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/12/MYSQL%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/12/MYSQL%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">MYSQL优化相关</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-12 20:33:57 / 修改时间：20:37:28" itemprop="dateCreated datePublished" datetime="2019-11-12T20:33:57+08:00">2019-11-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h3><h4 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h4><p>如何发现有问题的SQL？使用mysql慢查询日志对有效率问题的SQL进行监控</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//查看慢查询日志是否开启</span><br><span class="line">show variables like &apos;slow_query_log&apos;;</span><br><span class="line"></span><br><span class="line">//查看慢查询日志存储位置</span><br><span class="line">show variables like &apos;slow_query_log_file&apos;;</span><br><span class="line"></span><br><span class="line">//开启慢查询日志</span><br><span class="line">set global slow_query_log=on;</span><br><span class="line"></span><br><span class="line">//指定慢查询日志存储位置</span><br><span class="line">set global show_query_log_file=&apos;/var/lib/mysql/homestead-slow.log&apos;;</span><br><span class="line"></span><br><span class="line">//记录没有使用索引的sql</span><br><span class="line">set global log_queries_not_using_indexes=on;</span><br><span class="line"></span><br><span class="line">//记录查询超过1s的sql</span><br><span class="line">set global long_query_time=1;</span><br></pre></td></tr></table></figure>

<p>慢查询日志所包含的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#User@Host:root[root] @localhost[]//执行sql的主机信息</span><br><span class="line">#Query_time:0.0000024 Lock_time:0.00 Rows_sent:0 Rows_esamined:0//sql的执行信息</span><br><span class="line">SET timestamp=1402389324//sql执行时间</span><br><span class="line">select * from store; //sql的内容</span><br></pre></td></tr></table></figure>

<p><strong>MySQL慢查询日志分析工具之mysqldumpslow（mysql官方）</strong></p>
<p>安装完MySQL后，默认就带了mysqldumpslow，很常用的一个工具。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//查看参数列表</span><br><span class="line">mysqldumpslow -h</span><br><span class="line"></span><br><span class="line">//分析慢查询日志中前三条比较慢的sql</span><br><span class="line">mysqldumpslow -t 3 /var/lib/mysql/homestead-slow.log | more </span><br><span class="line"></span><br><span class="line">//输出样式效果</span><br><span class="line">Count:1 Time:0.00s Lock=0.00s Rows=10.0</span><br><span class="line">root[rppt]@localhost</span><br><span class="line">select * from store</span><br></pre></td></tr></table></figure>

<p><strong>MySQL慢查询日志分析工具之pt-query-digest</strong></p>
<p>分析结果比mysqldumpslow更详细全面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//输出到文件</span><br><span class="line">pt-query-digest slow-log &gt; slow_log.report</span><br><span class="line"></span><br><span class="line">//输出到数据表</span><br><span class="line">pt-query-digest slow.log -review \</span><br><span class="line">    h=127.0.0.1,D=test,p=root,P=3306,u=root,t=query_review \</span><br><span class="line">    --create-reviewtable \</span><br><span class="line">    --review-history t=hostname_slow</span><br></pre></td></tr></table></figure>

<p>基本使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//查看参数列表</span><br><span class="line">pt-query-digest --help</span><br><span class="line"></span><br><span class="line">//分析慢查询日志中前三条比较慢的sql</span><br><span class="line">pt-query-digest /var/lib/mysql/homestead-slow.log | more </span><br><span class="line"></span><br><span class="line">//输出分为三部分</span><br><span class="line">1.显示除了日志的时间范围，以及总的sql数量和不同的sql数量</span><br><span class="line">2.Response Time:响应时间占比 Calls:sql执行次数</span><br><span class="line">3.sql的具体日志</span><br></pre></td></tr></table></figure>

<p>如何通过慢查询日志发现有问题的SQL？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.查询次数多且每次查询占用时间长的SQL</span><br><span class="line">通常为pt-query-digest分析的前几个查询</span><br><span class="line"></span><br><span class="line">2.IO大的SQL（数据库主要瓶颈出现在IO层次）</span><br><span class="line">注意pt-query-digest分析中的Rows examine项</span><br><span class="line"></span><br><span class="line">3.未命中索引的SQL</span><br><span class="line">注意pt-query-digest分析中的Rows examine和Rows Send的对比</span><br></pre></td></tr></table></figure>

<p>通过explain查询和分析SQL的执行计划</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">explain select customer_id,,first_name,last_name from customer;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Column 1</th>
<th>Column 2</th>
<th>Column 3</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td></td>
<td></td>
</tr>
<tr>
<td>select_type</td>
<td>SIMPLE</td>
<td></td>
</tr>
<tr>
<td>table</td>
<td>customer</td>
<td>该数据关于哪张表。</td>
</tr>
<tr>
<td>type</td>
<td>ALL</td>
<td>示连接使用了何种类型。从好到差const,eq_reg,ref,range,index和ALL。</td>
</tr>
<tr>
<td>possible_keys</td>
<td>NULL</td>
<td>可能应用在该表的索引，空，没有可能的索引。</td>
</tr>
<tr>
<td>key</td>
<td>NULL</td>
<td>实际使用的索引。空，没有使用索引。</td>
</tr>
<tr>
<td>key_len</td>
<td>NULL</td>
<td>使用的索引长度。不损失精度下，越短越好。</td>
</tr>
<tr>
<td>ref</td>
<td>NULL</td>
<td>显示索引的哪一列被使用了，常数。</td>
</tr>
<tr>
<td>rows</td>
<td>671</td>
<td>mysql认为必须检查的数据的行数。</td>
</tr>
<tr>
<td>Extra</td>
<td>‘</td>
<td>注意：Using filesort,Using tempoary</td>
</tr>
</tbody></table>
<h4 id="Count-和Max-的优化"><a href="#Count-和Max-的优化" class="headerlink" title="Count()和Max()的优化"></a>Count()和Max()的优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//查询最后支付时间--优化max()函数</span><br><span class="line">explain select max(payment_date) from payment;</span><br><span class="line">create index idx_paydate on payment(payment_data);//给payment_date建立索引(覆盖索引)</span><br><span class="line"></span><br><span class="line">//在一条SQL中同时查出2006年和2007年电影的数量--优化Count()函数</span><br><span class="line">select count(release_year=&apos;2006&apos; or null) as &apos;2006年电影数量&apos;，count(release_year=&apos;2007&apos; or null) as &apos;2007年电影数量&apos; from film;</span><br><span class="line">//有关count()函数</span><br><span class="line">https://blog.csdn.net/wendychiang1991/article/details/70909958/</span><br></pre></td></tr></table></figure>

<h4 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">通常情况下，需要把子查询优化为join查询，但在优化时要注意关联键是否有一对多的关系，要注意重复数据。(distinct去重)</span><br><span class="line">//查询sandra出演的所有影片</span><br><span class="line">explain select title,release_year,LENGTH from film</span><br><span class="line">where film_id in (</span><br><span class="line">select film_id from film_actor where actor_id in (</span><br><span class="line">select actor_id from actor where first_name=&apos;sandra&apos;));</span><br></pre></td></tr></table></figure>

<h4 id="group-by的优化"><a href="#group-by的优化" class="headerlink" title="group by的优化"></a>group by的优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//改前 临时表</span><br><span class="line">explain select actor.first_name,actor_last_name,count(*) from sakila.film_actor</span><br><span class="line">inner join sakila.actor USING(actor_id)</span><br><span class="line">group by film_actor.actor_id;</span><br><span class="line">//改后 结合子查询 索引</span><br><span class="line">explain select actor.first_name,actor.last_name,c.cnt from sakila.film_actor</span><br><span class="line">inner join (</span><br><span class="line">select actor_id,count(*) as cnt from sakila.film_actor group by actor_id) as c USING(actor_id);</span><br></pre></td></tr></table></figure>

<h4 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">limit常用于分页处理，时常会伴随order by 从句使用，因此大多时候会使用Filesorts这样会造成大量的IO问题。</span><br><span class="line"></span><br><span class="line">//文件排序，IO大</span><br><span class="line">explain select film_id,description from sakila.film order by title limit 50,5;</span><br><span class="line">1.优化：使用有索引的列或主键进行order by操作（order by film_id）</span><br><span class="line">2.记录上次返回的主键，在下次查询的时候用主键过滤，避免了数据量大时扫描过多的记录</span><br><span class="line">select film_id,description from sakila.film where film_if&gt;55 and film_id&lt;=60 order by film_id limit 1,5; </span><br><span class="line">页数越大，IO越大</span><br></pre></td></tr></table></figure>

<h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><h4 id="如何选择合适的列建立索引？"><a href="#如何选择合适的列建立索引？" class="headerlink" title="如何选择合适的列建立索引？"></a>如何选择合适的列建立索引？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.在where从句，group by从句，order by从句，on从句中出现的列(select)</span><br><span class="line">2.索引字段越小越好(表每页数据才会更多，IO效率会更高)</span><br><span class="line">3.离散度大的列放到联合索引的前面</span><br><span class="line">select * from payment where staff_id=2 and customer_id=584;</span><br><span class="line">index(staff_id,customer_id)好？还是index(customer_id,staff_id)好？</span><br><span class="line">由于customer_id的离散度更大(重复率小,可选择性更大)，所以应该使用index(customer_id,staff_id)</span><br></pre></td></tr></table></figure>

<h4 id="索引优化SQL的方法"><a href="#索引优化SQL的方法" class="headerlink" title="索引优化SQL的方法"></a>索引优化SQL的方法</h4><p>索引的维护及优化–重复及冗余索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">冗余索引是指多个索引的前缀列相同，或是在联合索引中包含了主键的索引。如下：key(name,id)就是一个冗余索引</span><br><span class="line">create table test(</span><br><span class="line">id int not null primary key,</span><br><span class="line">name varchar(10) not null,</span><br><span class="line">key(name,id)</span><br><span class="line">)engine=innodb;</span><br><span class="line">//可以删除冗余索引，达到优化效果。</span><br><span class="line"></span><br><span class="line">使用pt-duplicate-key-checker工具检查重复及冗余索引</span><br><span class="line">pt-duplicate-key-checker \</span><br><span class="line">-uroot \</span><br><span class="line">-p &apos;&apos; \</span><br><span class="line">-h 127.0.0.1</span><br></pre></td></tr></table></figure>

<p>索引维护的方法–删除不用索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">目前mysql中还没有记录索引的使用情况，但是在PerconMySQL和MariaDB中可通过INDEX_STATISTICS表来查看哪些索引未使用，但在mysql中目前只能通过慢查日志配合pt-index-usage工具来进行索引使用情况分析。</span><br><span class="line">pt-index-usage \</span><br><span class="line">    -uroot -p&apos;&apos; \</span><br><span class="line">    mysql-slow.log</span><br></pre></td></tr></table></figure>

<h3 id="数据库表结构优化"><a href="#数据库表结构优化" class="headerlink" title="数据库表结构优化"></a>数据库表结构优化</h3><h4 id="选择合适的数据类型"><a href="#选择合适的数据类型" class="headerlink" title="选择合适的数据类型"></a>选择合适的数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.使用可以存下你的数据的最小的数据类型</span><br><span class="line">2.使用简单的数据类型。int要比varchar类型在mysql处理上更简单</span><br><span class="line">3.尽可能的使用not null定义字段</span><br><span class="line">4.尽量少用text类型，非用不可时最好考虑分表</span><br><span class="line">*使用int来存储日志时间，利用FROM_UNIXTINE()(得到日期),UNIX_TIMESTAMP()(得到时间戳)两个函数来进行转换</span><br><span class="line">*使用bigint来存ip地址，利用INET_ATON(),INET_NTOA()两个函数来进行转换</span><br></pre></td></tr></table></figure>

<h4 id="表的范式化和反范式化"><a href="#表的范式化和反范式化" class="headerlink" title="表的范式化和反范式化"></a>表的范式化和反范式化</h4><p>范式化是指数据库设计的规范，目前说到范式化一般是指第三设计范式，也就是要求数据表中不存在非关键字段对任意候选关键字段的传递函数依赖则符合第三范式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">不符合第三范式要求的表存在下列问题：</span><br><span class="line">1.数据冗余：（分类，分类描述）对于每一个商品都会进行记录</span><br><span class="line">2.数据的插入异常</span><br><span class="line">3.数据的更新异常</span><br><span class="line">4.数据的删除异常</span><br></pre></td></tr></table></figure>

<p>反范式化是指为了查询效率的考虑把原本符合第三范式的表适当的增加冗余，以达到优化查询的目的，反范式化是一种以空间来换取时间的操作。</p>
<h4 id="表的拆分"><a href="#表的拆分" class="headerlink" title="表的拆分"></a>表的拆分</h4><p>垂直拆分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">所谓的垂直拆分，就是把原来一个有很多列的表拆分成多个表，这解决了表的宽度问题。通常垂直拆分可以按以下原则进行：</span><br><span class="line">1.把不常用的字段单独存放到一个表中</span><br><span class="line">2.把大字段独立存放到一个表中</span><br><span class="line">3.把经常一起使用的字段放到一起</span><br></pre></td></tr></table></figure>

<p>水平拆分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">表的水平拆分是为了解决单表的数据量过大的问题，水平拆分的表每一个表的结构都是完全一致的。</span><br><span class="line">常用的水平拆分方法为：</span><br><span class="line">1.对id进行hash运算，如果要拆分成5个表则使用mod(id,5)去除0-4个值</span><br><span class="line">2.针对不同的hashID把数据存到不同的表中</span><br></pre></td></tr></table></figure>

<p>转自<a href="https://www.zam9.com/blog/mysql_opt01#SQL%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96" target="_blank" rel="noopener">https://www.zam9.com/blog/mysql_opt01#SQL%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/11/%E6%AD%BB%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/11/%E6%AD%BB%E9%94%81/" class="post-title-link" itemprop="url">死锁</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-11 21:18:02 / 修改时间：21:21:09" itemprop="dateCreated datePublished" datetime="2019-11-11T21:18:02+08:00">2019-11-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/" itemprop="url" rel="index">
                    <span itemprop="name">手撕代码</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class DeadLockDome &#123;</span><br><span class="line"></span><br><span class="line">	private static String A = &quot;A&quot;;</span><br><span class="line"></span><br><span class="line">	private static String B = &quot;B&quot;;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new DeadLockDome().DeadLock();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private void DeadLock() &#123;</span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				// TODO Auto-generated method stub</span><br><span class="line">				synchronized (A) &#123;</span><br><span class="line">					System.out.println(&quot;获得A对象&quot;);</span><br><span class="line">					synchronized (B) &#123;</span><br><span class="line">						System.out.println(&quot;获得B对象&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				synchronized (B) &#123;</span><br><span class="line">					System.out.println(&quot;获得B对象&quot;);</span><br><span class="line">					synchronized (A) &#123;</span><br><span class="line">						System.out.println(&quot;获得A对象&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/11/%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/11/%E6%B3%9B%E5%9E%8B/" class="post-title-link" itemprop="url">泛型</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-11 15:40:12 / 修改时间：15:50:51" itemprop="dateCreated datePublished" datetime="2019-11-11T15:40:12+08:00">2019-11-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA基础</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p><strong>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</strong></p>
<p><strong>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）</strong>。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>
<h3 id="泛型的作用"><a href="#泛型的作用" class="headerlink" title="泛型的作用"></a>泛型的作用</h3><p>1，类型安全。 </p>
<pre><code>泛型的主要目标是提高 Java 程序的类型安全。编译时的强类型检查；通过知道使用泛型定义的变量的类型限制，编译器可以在一个高得多的程度上验证类型假设。没有泛型，这些假设就只存在于程序员的头脑中（或者如果幸运的话，还存在于代码注释中）。</code></pre><p>2，消除强制类型转换。 </p>
<pre><code>泛型的一个附带好处是，消除源代码中的许多强制类型转换。这使得代码更加可读，并且减少了出错机会。</code></pre><p>3，潜在的性能收益。 </p>
<pre><code>泛型为较大的优化带来可能。在泛型的初始实现中，编译器将强制类型转换（没有泛型的话，程序员会指定这些强制类型转换）插入生成的字节码中。但是更多类型信息可用于编译器这一事实，为未来版本的 JVM 的优化带来可能。由于泛型的实现方式，支持泛型（几乎）不需要 JVM 或类文件更改。所有工作都在编译器中完成，编译器生成类似于没有泛型（和强制类型转换）时所写的代码，只是更能确保类型安全而已。

 Java语言引入泛型的好处是安全简单。泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。</code></pre><p>4、更好的代码复用性，比如实现泛型算法</p>
<pre><code>在框架设计时候，BaseDao&lt;T&gt;、BaseService&lt;T&gt;、BaseDaoImpl&lt;T&gt;、BaseServiceImpl&lt;T&gt;；通过继承，实现抽象了所有公共方法，避免了每次都要写相同的代码。</code></pre><h3 id="使用泛型的注意事项"><a href="#使用泛型的注意事项" class="headerlink" title="使用泛型的注意事项"></a>使用泛型的注意事项</h3><p>1、泛型的类型参数只能是类类型（包括自定义类），不可以是简单类型。</p>
<pre><code>2、同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。

3、泛型的类型参数可以有多个。

4、泛型的参数类型可以使用extends语句，例如&lt;T extends superclass&gt;。习惯上成为“有界类型”。

5、泛型的参数类型还可以是通配符类型。例如Class&lt;?&gt; classType = Class.forName(Java.lang.String);</code></pre><h3 id="泛型的工作原理"><a href="#泛型的工作原理" class="headerlink" title="泛型的工作原理"></a>泛型的工作原理</h3><p> Java的泛型是伪泛型。在编译期间，所有的泛型信息都会被擦除掉。正确理解泛型概念的首要前提是理解类型擦出（type erasure）。</p>
<p>​       Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会在编译器在编译的时候去掉。这个过程就称为类型擦除。</p>
<p>​     如在代码中定义的List<object>和List<String>等类型，在编译后都会编程List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。</String></object></p>
<h3 id="泛型的使用方法"><a href="#泛型的使用方法" class="headerlink" title="泛型的使用方法"></a>泛型的使用方法</h3><p>（1）泛型类</p>
<p>泛型类也就是把泛型定义在类上，这样用户在使用类的时候才把类型给确定下来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectTool&lt;T&gt; &#123;</span><br><span class="line">    private T obj;</span><br><span class="line"></span><br><span class="line">    public T getObj() &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setObj(T obj) &#123;</span><br><span class="line">        this.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上面这个程序，在使用时如果定义了类型，那么在使用时就可以不用进行强制类型转换，直接就可以得到一个T类型的对象。</p>
<p>（2）泛型方法<br>有时候只关心某个方法，那么使用泛型时可以不定义泛型类，而是只定义一个泛型方法，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; void show(T t) &#123;</span><br><span class="line">       System.out.println(t);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>需要注意一下定义的格式，泛型必须得先定义才能够使用。</p>
<p>（3）继承关系<br>泛型类在继承时，可以明确父类（泛型类）的参数类型，也可以不明确。<br>现在我们有如下的泛型类<br>//泛型类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Inter&lt;T&gt; &#123;</span><br><span class="line">    public abstract void show(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>①明确类型<br>//在实现泛型类时明确父类的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class InterImpl implements Inter&lt;String&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show(String s) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②不明确类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class InterImpl&lt;T&gt; implements Inter&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void show(T t) &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/10/%E8%BE%93%E5%85%A5url%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/10/%E8%BE%93%E5%85%A5url%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/" class="post-title-link" itemprop="url">输入url发生什么</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-10 22:44:47 / 修改时间：22:51:33" itemprop="dateCreated datePublished" datetime="2019-11-10T22:44:47+08:00">2019-11-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>从开发&amp;运维角度方面来看，总体来说分为以下几个过程</p>
<ul>
<li>查找浏览器缓存</li>
<li>DNS 解析:将域名解析成 IP 地址</li>
<li>TCP 连接：TCP 三次握手</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>断开连接：TCP 四次挥手</li>
</ul>
<p>首先我们需要知道TCP/IP的网络模型，这里我就以四层模型为例子。</p>
<p>。</p>
<p><img src="http://images0.cnblogs.com/blog/622045/201507/020946547655321.png" alt="这里写图片描述"></p>
<p>第一步：在浏览器中输入<a href="http://www.baidu.com后，应用层会使用DNS解析域名，如果本地存有对应的IP，则使用；如果没有，则会向上级DNS服务器请求帮助，直至获得IP。域名解析详细过程会在下文讲到。" target="_blank" rel="noopener">www.baidu.com后，应用层会使用DNS解析域名，如果本地存有对应的IP，则使用；如果没有，则会向上级DNS服务器请求帮助，直至获得IP。域名解析详细过程会在下文讲到。</a></p>
<p>第二步：应用层将请求的信息装载入HTTP请求报文，信息包含了请求的方法（GET / POST）、目标url、遵循的协议（http / https / ftp…）等，然后应用层将发起HTTP请求。</p>
<p>第三步：传输层接收到应用层传递下来的数据，并分割成以报文段为单位的数据包进行管理，并为它们编号，方便服务器接收时能准确地还原报文信息。通过三次握手和目标端口建立安全通信。</p>
<p>第四步：网络层接收传输层传递的数据，根据IP通过ARP协议获得目标计算机物理地址—MAC。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标。</p>
<p>第五步：找到目标MAC地址以后，就将数据发送到数据链路层，这时开始真正的传输请求信息，传输完成以后请求结束。</p>
<p>第六步：服务器接收数据后，从下到上层层将数据解包，直到应用层。</p>
<p>第七步： 服务器接收到客户端发送的HTTP请求后，查找客户端请求的资源，将数据装载入响应报文并返回，响应报文中包括一个重要的信息——状态码，如200,404,500。<br>————————————————<br>版权声明：本文为CSDN博主「早就戒了」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_37169817/article/details/78663598" target="_blank" rel="noopener">https://blog.csdn.net/qq_37169817/article/details/78663598</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/10/TCP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/10/TCP/" class="post-title-link" itemprop="url">三次握手四次挥手</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-10 22:12:48 / 修改时间：22:37:43" itemprop="dateCreated datePublished" datetime="2019-11-10T22:12:48+08:00">2019-11-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="TCP报文（标准长度20字节）"><a href="#TCP报文（标准长度20字节）" class="headerlink" title="TCP报文（标准长度20字节）"></a>TCP报文（标准长度20字节）</h3><p><a href="https://a5223594.github.io/2019/09/25/传输层/20150611163052331.png" target="_blank" rel="noopener"><img src="https://a5223594.github.io/2019/09/25/%E4%BC%A0%E8%BE%93%E5%B1%82/20150611163052331.png" alt="TCP报文">TCP报文</a></p>
<p>TCP数据包每次能够传输的最大长度 = MTU(1500B) - IP头（20B）- TCP头（20B）= 1460Bytes。<br>源端口号与目的端口号：标识了发送方与接收方的地址，IP地址和端口号合称为套接字。</p>
<h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><ul>
<li>序列号和确认号：32位序列号与32位确认序号：序列号与确认号可以理解成两个通信进程在收发数据的时候互相应答的信息。比如说：A进程从序列号1000开始给B进程发送数据，发送五个数据。那么在B收到数据回复的时候，这里A的确认序列号应该是从1006，如果不是1006，比如说是1003，那就意味着1004、1005数据包B没有收到，于是A启动重发机制。这也就保证了数据的可靠性，也是TCP的特点之一。序列号是进程发送消息的号码，而确认号是期望目的进程返回的号码。进行比对，从而验证数据包是否到达。</li>
<li>4位TCP报头长度：这里的四位TCP报头长度，可以理解成四个比特位表示长度，四位比特位表示的值乘以四就是该TCP头部的长度。由图可知，报头最短长度为20字节，也就是说这里的四位TCP报头长度默认为0101。并且TCP报头长度不可超过15*4=60个字节。</li>
<li>标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：<br>URG：紧急指针（urgent pointer）有效；<br><strong>ACK</strong>：确认序号有效；<br>PSH：接收方应该尽快将这个报文交给应用层；<br>RST：重置连接；<br><strong>SYN</strong>：发起一个新连接；<br><strong>FIN</strong>：释放一个连接。</li>
<li>16位窗口大小：<strong>窗口大小标志着TCP缓冲区内部剩余空间的大小，起到一个流量控制的作用。如果窗口满了，那么这个时候是不允许数据接收的</strong>。后面到达的数据会被丢失。</li>
<li>16位校验和：这里的校验和由发送端填充，CRC校验。接收端校验数据的时候如果校验不通过，那么认为数据有问题。此处的校验和不仅仅校验TCP首部，还校验数据部分。</li>
<li>16位紧急指针：标识哪部分的数据为紧急数据。</li>
</ul>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。 三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 <code>connect()</code> 时。将触发三次握手。</p>
<ul>
<li>第一次握手(SYN=1, seq=x): 客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。 发送完毕后，客户端进入 <code>SYN_SEND</code> 状态。</li>
<li>第二次握手(SYN=1, ACK=1,  seq=y, ACKnum=x+1): 服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq  域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 <code>SYN_RCVD</code> 状态。</li>
<li>第三次握手(ACK=1，ACKnum=y+1) 客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1 发送完毕后，客户端进入 <code>ESTABLISHED</code> 状态，当服务器端接收到这个包时，也进入 <code>ESTABLISHED</code> 状态，TCP 握手结束。</li>
</ul>
<p>三次握手的过程的示意图如下：</p>
<p><img src="https://nipingd.github.io/assets/img/1567496958834.b9702e14.png" alt="1567496958834"></p>
<h4 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h4><p>为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。</p>
<h3 id="半连接、半打开、半关闭状态"><a href="#半连接、半打开、半关闭状态" class="headerlink" title="半连接、半打开、半关闭状态"></a>半连接、半打开、半关闭状态</h3><p>半连接状态：发生在TCP三次握手过程中，客户端向服务器发起连接，服务器也进行了回应，但是客户端却不进行第3次握手。</p>
<p>半打开状态：在TCP连接中，如果某一端关闭了连接或者是异常关闭，则该连接处于半打开状态。解决半打开问题：引入心跳机制就可以察觉半打开状态。</p>
<p>半关闭状态：当TCP链接中客户端向服务器发送 FIN 请求关闭，服务端回应ACK之后，并没有立即发送 FIN  给客户端，客户端就处于半关闭状态，此时客户端可以接收服务器发送的数据，但是客户端已经不能再向服务器发送数据。(应用层面，传输层服务端发送信号，客户端还是得发送响应)</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><a href="https://a5223594.github.io/2019/09/25/传输层/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" target="_blank" rel="noopener"><img src="https://a5223594.github.io/2019/09/25/%E4%BC%A0%E8%BE%93%E5%B1%82/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" alt="四次挥手">四次挥手</a></p>
<p>第一次挥手：Client发送一个FIN，Seq=K，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态；<br>第二次挥手：Server收到FIN后，发送一个ACK（K+1）给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态；<br>第三次挥手：Server发送一个FIN，Seq=L，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态；<br>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态（等待2MSL后关闭），接着发送一个ACK（L+1）给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p>
<h4 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"></a>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</h4><p>原因在于：首先FIN信号是由于调用close所以才发送的，而ACK是由内核发送的，所以ACK报文和FIN报文在发送的时间上都是分开的，不一定能同时发送。但是三次握手的时候发送SYN是由内核直接完成的，所以这就可以达到一个同步发送的情况。</p>
<h3 id="滑动窗口（流量控制）"><a href="#滑动窗口（流量控制）" class="headerlink" title="滑动窗口（流量控制）"></a>滑动窗口（流量控制）</h3><p>在确认应答机制中，对每一个发送的数据段，都要给一个ACK确认应答，收到ACK后再发送下一个数据段。这样做有一个比较大的缺点，就是性能较差。尤其是数据往返时间较长的时候。那么我们可不可以一次发送多个数据段呢：滑动窗口。<br>所谓的流量控制就是让发送方的发送速率不要太快，让接收方来得及接收。利用滑动窗口机制可以很方便的在TCP连接上实现对发送方的流量控制。</p>
<ul>
<li>接收端窗口rwnd（recv window）：接收端缓冲区大小。接收端将此窗口值放在 TCP 报文的首部中的窗口字段，传送给发送端；</li>
<li>拥塞窗口cwnd（congestion window）：发送端缓冲区大小；</li>
<li>发送窗口swnd（send window）：发送窗口的上限值 = Min [rwnd, cwnd]。</li>
</ul>
<p><a href="https://a5223594.github.io/2019/09/25/传输层/20180524132418928.png" target="_blank" rel="noopener"><img src="https://a5223594.github.io/2019/09/25/%E4%BC%A0%E8%BE%93%E5%B1%82/20180524132418928.png" alt="滑动窗口">滑动窗口</a></p>
<p><strong>滑动窗口内部的数据都是已经发送但是没有收到ACK应答的数据</strong>，滑动窗口<strong>左侧都是已经收到了ACK应答的数据</strong>，滑动窗口<strong>右侧是未发送的数据</strong>。</p>
<p>TCP协议规定，接收到三个重复的ACK响应，就开始重传响应所要求的报文的机制就是快重传速机制。<br>接收端ACK响应丢包其实对发送端发送的影响并不是那么大，后续的ACK响应能够处理好这个问题。</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>拥塞控制也就是考虑当前的网络环境，动态调整窗口大小，没有发生拥塞情况，则窗口增大，拥塞了窗口减小，如此往复，最终应该接近与接收端的窗口大小。</p>
<ol>
<li>慢启动和拥塞避免<br>在开始发送信息时，由于不知道具体的网络环境，为避免大量信息造成的拥塞现象，此时的拥塞窗口以最小值（即拥塞窗口和接收端窗口中的较小值）进行数据发送，并设定门限值作为慢启动算法和拥塞避免算法的分割点。慢启动是指以最小的拥塞窗口按照指数形式递增，达到门限值后，以拥塞避免算法，即线性递增方式增大拥塞窗口（这里递增时间间隔为一个往返时间RTT）。<br>在上述过程中，无论是窗口大小指数递增或者线性递增，当发生拥塞现象，则门限值更新为当前窗口大小的一半，拥塞窗口大小变为最小值，重复上述递增过程（此时属于网络环境限制，所以在接收端和拥塞窗口两个限制条件中选择拥塞窗口作为限制）。</li>
</ol>
<p><a href="https://a5223594.github.io/2019/09/25/传输层/20181028161235619.jpeg" target="_blank" rel="noopener"><img src="https://a5223594.github.io/2019/09/25/%E4%BC%A0%E8%BE%93%E5%B1%82/20181028161235619.jpeg" alt="拥塞控制">拥塞控制</a></p>
<ol>
<li>快重传和快恢复<br>当发送端连续收到三个重复的ack时，表示该数据段已经丢失，需要重发。当收到三个表示同一个数据段的ack时，不需要等待计时器超时，立即重新发送数据段（当时这三个ack要在超时之前到达发送端），因为能够收到接收端的ack确认信息，所以数据段只是单纯的丢失，而不是因为网络拥塞导致，所以此时不需要拥塞窗口更新为最小值进行慢启动（如果这样的话，反倒因为拥塞窗口的增长需要时间，可能导致性能降低），此时需要设置拥塞窗口大小为：门限值大小+3，当然此处的门限值已经更新为拥塞窗口值的一半大小，该行为也就是所谓的“乘法减少”，更新之后按照拥塞避免算法继续进行。</li>
<li>拥塞窗口大小为什么先以指数增加再以线性增加？<br>窗口大小首先以指数递增去探测一下网络的拥塞程度，执行拥塞避免算法后，拥塞窗口线性缓慢增大，防止网络过早出现拥塞。</li>
</ol>
<h3 id="粘包问题"><a href="#粘包问题" class="headerlink" title="粘包问题"></a>粘包问题</h3><p>TCP是基于字节流传输的，只维护发送出去多少，确认了多少，没有维护消息与消息之间的边界，因而可能导致粘包问题。<br>粘包问题本质上要在应用层维护消息与消息的边界。解决方案如下：</p>
<blockquote>
<p>在接收端接收的时候采用定长的方式接收；<br>在数据包尾添加一些分隔符；<br>在数据包头部加上数据包长度；<br>更复杂的应用层协议。</p>
</blockquote>
<h3 id="为什么udp不会粘包？"><a href="#为什么udp不会粘包？" class="headerlink" title="为什么udp不会粘包？"></a>为什么udp不会粘包？</h3><ol>
<li>TCP协议是面向流的协议，UDP是面向消息的协议<br>UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据</li>
<li>UDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样对于接收端来说就容易进行区分处理了。传输协议把数据当作一条独立的消息在网上传输，接收端只能接收独立的消息。接收端一次只能接收发送端发出的一个数据包,如果一次接受数据的大小小于发送端一次发送的数据大小，就会丢失一部分数据，即使丢失，接受端也不会分两次去接收</li>
</ol>
<h3 id="UDP-和-TCP-的特点"><a href="#UDP-和-TCP-的特点" class="headerlink" title="UDP 和 TCP 的特点"></a>UDP 和 TCP 的特点</h3><ul>
<li>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>传输控制协议  TCP（Transmission Control   Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条   TCP 连接只能是点对点的（一对一）。</li>
</ul>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP数据报最大长度64K（包含UDP首部），如果数据长度超过64K就需要在应用层手动分包，UDP无法保证包序，需要在应用层进行编号。</p>
<ul>
<li>特点</li>
</ul>
<ol>
<li>无连接：知道对端的IP和端口号就直接进行传输, 不需要建立连接。</li>
<li>不可靠：没有确认机制, 没有重传机制; 如果因为网络故障该段无法发到对方, UDP协议层也不会给应用层返回任何错误信息。</li>
<li>面向数据报：不能够灵活的控制读写数据的次数和数量，应用层交给UDP多长的报文, UDP原样发送, 既不会拆分, 也不会合并。</li>
<li>数据收不够灵活，但是能够明确区分两个数据包，避免粘包问题。</li>
</ol>
<ul>
<li><p>协议：</p>
<blockquote>
<p>NFS: 网络文件系统<br>TFTP: 简单文件传输协议<br>DHCP: 动态主机配置协议<br>BOOTP: 启动协议(用于无盘设备启动)<br>DNS: 域名解析协议</p>
</blockquote>
</li>
</ul>
<h3 id="基于-UDP-的几个例子"><a href="#基于-UDP-的几个例子" class="headerlink" title="基于 UDP 的几个例子"></a>基于 UDP 的几个例子</h3><ul>
<li>直播。直播对实时性的要求比较高，宁可丢包，也不要卡顿的，所以很多直播应用都基于 UDP 实现了自己的视频传输协议</li>
<li>实时游戏。游戏的特点也是实时性比较高，在这种情况下，采用自定义的可靠的 UDP 协议，自定义重传策略，能够把产生的延迟降到最低，减少网络问题对游戏造成的影响</li>
<li>物联网。一方面，物联网领域中断资源少，很可能知识个很小的嵌入式系统，而维护 TCP  协议的代价太大了；另一方面，物联网对实时性的要求也特别高。比如 Google 旗下的 Nest 简历 Thread  Group，推出了物联网通信协议 Thread，就是基于 UDP 协议的</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/10/%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/10/%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">几种排序算法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-10 16:23:42 / 修改时间：16:37:29" itemprop="dateCreated datePublished" datetime="2019-11-10T16:23:42+08:00">2019-11-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/" itemprop="url" rel="index">
                    <span itemprop="name">手撕代码</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static void insertSort(int[] arr) &#123;</span><br><span class="line">	// TODO Auto-generated method stub</span><br><span class="line">	</span><br><span class="line">	int i,j,temp;</span><br><span class="line">	for(i=1;i&lt;arr.length;i++) &#123;//从第二个数往后遍历</span><br><span class="line">		temp=arr[i];//暂存第i个元素</span><br><span class="line">		for(j=i-1;j&gt;=0;j--) &#123;//从i-1个元素往前遍历</span><br><span class="line">			if(temp&lt;=arr[j]) &#123;//temp&lt;=arr[j]时，元素后移一位</span><br><span class="line">				arr[j+1]=arr[j];</span><br><span class="line">			&#125;else &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		arr[j+1]=temp;//插入</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>时间复杂度O(n^2)</li>
<li>稳定排序</li>
<li>使用于链式结构，也使用于数组</li>
<li>适合初始基本有序的情况，当初始无序 N较大是不适用</li>
</ol>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static void selectSort(int[] arr) &#123;</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; arr.length - 1; i++) &#123;//选择一趟最小元素</span><br><span class="line">		int min = i;//把当前指向的第一个元素的下标存在min中</span><br><span class="line">		for (int j = i + 1; j &lt; arr.length - 1; j++) &#123;//遍历当前指向的第一个元素后面的元素</span><br><span class="line">			if (arr[j] &lt; arr[min]) &#123;//如果找到比第一个元素小的，把较小的元素下标存在min中</span><br><span class="line"></span><br><span class="line">				min = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (min != i) &#123;//如果min不等于开始存的第一个元素的下标，则把第一个元素与较小的元素做交换</span><br><span class="line">			int temp = arr[i];</span><br><span class="line">			arr[i] = arr[min];</span><br><span class="line">			arr[min] = temp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>时间复杂度O(n^2)</p>
</li>
<li><p>不稳定</p>
</li>
<li><p>使用于链式结构，也使用于数组</p>
</li>
</ol>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static void bubbleSort(int[] arr) &#123;</span><br><span class="line">	</span><br><span class="line">	int n = arr.length-1;//取数组长度</span><br><span class="line">	</span><br><span class="line">	for(int i=0 ;i&lt;n;i++) &#123;//冒泡的趟数</span><br><span class="line">		boolean flag = false;//表示不发生交换</span><br><span class="line">		for(int j =0;j&lt;n-i;j++) &#123;//剩下的进行冒泡的元素</span><br><span class="line">			if(arr[j]&gt;arr[j+1]) &#123;//若该元素比下一个元素大则把交换标志置位true，交换两个数</span><br><span class="line">				flag = true;</span><br><span class="line">				int temp = arr[j];</span><br><span class="line">				arr[j] = arr[j+1];</span><br><span class="line">				arr[j+1] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(!flag) break;//没发生数据交换退出排序</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>时间复杂度O(n^2)</li>
<li>不稳定</li>
<li>使用于链式结构，也使用于数组</li>
<li>N较大是不适用</li>
</ol>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private static void quickSort(int[] arr, int low, int high) &#123;</span><br><span class="line">		if (low &lt; high) &#123;</span><br><span class="line">			int Index = getIndex(arr, low, high);//取得本次排序标记元素的索引</span><br><span class="line">			quickSort(arr, 0, Index - 1);//递归标记左边的子序列</span><br><span class="line">			quickSort(arr, Index + 1, high);//递归标记右边的子序列</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static int getIndex(int[] arr, int low, int high) &#123;</span><br><span class="line"></span><br><span class="line">		int temp = arr[low];//用temp暂存第一个元素作为标记</span><br><span class="line">		while (low &lt; high) &#123;</span><br><span class="line">			while (low &lt; high &amp;&amp; arr[high] &gt;= temp) &#123;</span><br><span class="line">				high--;//当low指针小于high，而high指针指向的值有大于标记时，high指针往前移</span><br><span class="line">			&#125;</span><br><span class="line">			arr[low] = arr[high];//否则交换low指针和high指针指向的值</span><br><span class="line"></span><br><span class="line">			while (low &lt; high &amp;&amp; arr[low] &lt;= temp) &#123;</span><br><span class="line">				low++;//当low指针小于high，而low指针指向的值有小于标记时，low指针往后移</span><br><span class="line">			&#125;</span><br><span class="line">			arr[high] = arr[low];//否则交换low指针和high指针指向的值</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		arr[low] = temp;//最后low与high指针重合的所指向的索引就是标记元素所存放的地方</span><br><span class="line"></span><br><span class="line">		return low;//最后返回标记的索引位置</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>时间复杂度O(nlog2n)</li>
<li>不稳定</li>
<li>当初始无序 N较大适用</li>
</ol>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private static void mergeSort(int[] arr, int start, int end) &#123;</span><br><span class="line">		if (start &lt; end) &#123;//递归结束条件是切分到只剩一个元素</span><br><span class="line">			int mid = (start + end) / 2;</span><br><span class="line">			mergeSort(arr, start, mid);//对左边子序列进行切分</span><br><span class="line">			mergeSort(arr, mid + 1, end);//对右边子序列进行切分</span><br><span class="line">			merge(arr, start, mid, end);//合并</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static void merge(int[] arr, int start, int mid, int end) &#123;</span><br><span class="line">		int[] temp = new int[arr.length];//临时数组用来暂存排序后的数组</span><br><span class="line">		int p1 = start;//指向左边第一个元素</span><br><span class="line">		int p2 = mid + 1;//指向mid后边第一个元素</span><br><span class="line">		int k = start;</span><br><span class="line">		while (p1 &lt;= mid &amp;&amp; p2 &lt;= end) &#123;</span><br><span class="line">			if (arr[p1] &lt;= arr[p2]) &#123;//p1指向的值小于等于p2指向的值，则把p1存在temp数组里，继续向后遍历</span><br><span class="line">				temp[k] = arr[p1];</span><br><span class="line">				k++;</span><br><span class="line">				p1++;</span><br><span class="line">			&#125; else &#123;//同上</span><br><span class="line">				temp[k] = arr[p2];</span><br><span class="line">				k++;</span><br><span class="line">				p2++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		while (p1 &lt;= mid) &#123;//左边子数组还没遍历完，把剩下的数放到temp里</span><br><span class="line">			temp[k] = arr[p1];</span><br><span class="line">			k++;</span><br><span class="line">			p1++;</span><br><span class="line">		&#125;</span><br><span class="line">		while (p2 &lt;= end) &#123;//同上</span><br><span class="line">			temp[k] = arr[p2];</span><br><span class="line">			k++;</span><br><span class="line">			p2++;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i = start; i &lt;= end; i++) &#123;//把temp数组逐一放到原数组中</span><br><span class="line">			arr[i] = temp[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>时间复杂度O(nlog2n)</li>
<li>稳定</li>
<li>使用于链式结构，也使用于数组</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/05/%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/05/%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">优化</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-05 15:32:37 / 修改时间：15:43:29" itemprop="dateCreated datePublished" datetime="2019-11-05T15:32:37+08:00">2019-11-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><h4 id="定位慢SQL，并优化"><a href="#定位慢SQL，并优化" class="headerlink" title="定位慢SQL，并优化"></a>定位慢SQL，并优化</h4><p>这是最常用、每一个技术人员都应该掌握基本的SQL调优手段（包括方法、工具、辅助系统等）。这里以MySQL为例，最常见的方式是，由自带的慢查询日志或者开源的慢查询系统定位到具体的出问题的SQL，然后使用explain、profile等工具来逐步调优，最后经过测试达到效果后上线。</p>
<h4 id="合理使用索引"><a href="#合理使用索引" class="headerlink" title="合理使用索引"></a>合理使用索引</h4><h4 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h4><h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>当一台服务器不能满足需求时，采用读写分离【写: update/delete/add】的方式进行集群。<br>一台数据库支持最大连接数是有限的，如果用户的并发访问很多，一台服务器无法满足需求，可以集群处理。mysql集群处理技术最常用的就是读写分离。</p>
<p>主从同步：数据库最终会把数据持久化到磁盘，集群必须确保每个数据库服务器的数据是一致的。从库读主库写，从库从主库上同步数据。<br>读写分离：使用负载均衡实现，写操作都往主库上写，读操作往从服务器上读。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h3 id="查询性能优化"><a href="#查询性能优化" class="headerlink" title="查询性能优化"></a>查询性能优化</h3><h4 id="使用-Explain-进行分析"><a href="#使用-Explain-进行分析" class="headerlink" title="使用 Explain 进行分析"></a><strong>使用 Explain 进行分析</strong></h4><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p>
<p>比较重要的字段有：</p>
<ul>
<li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>
<li>key : 使用的索引</li>
<li>rows : 扫描的行数</li>
</ul>
<h4 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a><strong>优化数据访问</strong></h4><h5 id="1-减少请求的数据量"><a href="#1-减少请求的数据量" class="headerlink" title="1. 减少请求的数据量"></a>1. 减少请求的数据量</h5><ul>
<li>只返回必要的列：最好不要使用 SELECT * 语句。</li>
<li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li>
<li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li>
</ul>
<h5 id="2-减少服务器端扫描的行数"><a href="#2-减少服务器端扫描的行数" class="headerlink" title="2. 减少服务器端扫描的行数"></a>2. 减少服务器端扫描的行数</h5><p>最有效的方式是使用索引来覆盖查询。</p>
<h4 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h4><h5 id="1-切分大查询"><a href="#1-切分大查询" class="headerlink" title="1. 切分大查询"></a>1. 切分大查询</h5><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> messages <span class="keyword">WHERE</span> <span class="keyword">create</span> &lt; <span class="keyword">DATE_SUB</span>(<span class="keyword">NOW</span>(), <span class="built_in">INTERVAL</span> <span class="number">3</span> <span class="keyword">MONTH</span>);</span><br><span class="line">rows_affected = 0</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    rows_affected = do_query(</span><br><span class="line">    <span class="string">"DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000"</span>)</span><br><span class="line">&#125; <span class="keyword">while</span> rows_affected &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h5 id="2-分解大连接查询"><a href="#2-分解大连接查询" class="headerlink" title="2. 分解大连接查询"></a>2. 分解大连接查询</h5><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p>
<ul>
<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li>
<li>减少锁竞争；</li>
<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li>
<li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag</span><br><span class="line"><span class="keyword">JOIN</span> tag_post <span class="keyword">ON</span> tag_post.tag_id=tag.id</span><br><span class="line"><span class="keyword">JOIN</span> post <span class="keyword">ON</span> tag_post.post_id=post.id</span><br><span class="line"><span class="keyword">WHERE</span> tag.tag=<span class="string">'mysql'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag=<span class="string">'mysql'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id=<span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post.id <span class="keyword">IN</span> (<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>,<span class="number">9098</span>,<span class="number">8904</span>);</span><br></pre></td></tr></table></figure>

<h3 id="分表优化"><a href="#分表优化" class="headerlink" title="分表优化"></a>分表优化</h3><h4 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h4><p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p>
<p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p>
<p> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg" alt="img"> </p>
<h4 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h4><p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p>
<p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p>
<p> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e130e5b8-b19a-4f1e-b860-223040525cf6.jpg" alt="img"> </p>
<h4 id="Sharding-策略"><a href="#Sharding-策略" class="headerlink" title="Sharding 策略"></a>Sharding 策略</h4><ul>
<li>哈希取模：hash(key) % N；</li>
<li>范围：可以是 ID 范围也可以是时间范围；</li>
<li>映射表：使用单独的一个数据库来存储映射关系。</li>
</ul>
<h4 id="Sharding-存在的问题"><a href="#Sharding-存在的问题" class="headerlink" title="Sharding 存在的问题"></a>Sharding 存在的问题</h4><p><strong>1. 事务问题</strong></p>
<p>使用分布式事务来解决，比如 XA 接口。</p>
<p><strong>2. 连接</strong></p>
<p>可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。</p>
<ol start="3">
<li><strong>ID 唯一性</strong></li>
</ol>
<ul>
<li>使用全局唯一 ID（GUID）</li>
<li>为每个分片指定一个 ID 范围</li>
<li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)</li>
</ul>
<h3 id="读写分离-1"><a href="#读写分离-1" class="headerlink" title="读写分离"></a>读写分离</h3><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p>
<p>读写分离能提高性能的原因在于：</p>
<ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li>
<li>增加冗余，提高可用性。</li>
</ul>
<p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p>
<p> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/master-slave-proxy.png" alt="img"> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/05/%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/05/%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">索引</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-05 14:24:14 / 修改时间：15:21:30" itemprop="dateCreated datePublished" datetime="2019-11-05T14:24:14+08:00">2019-11-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="B-Tree-原理"><a href="#B-Tree-原理" class="headerlink" title="B+ Tree 原理"></a>B+ Tree 原理</h3><p>详解B+树</p>
<p><img src="https://img-blog.csdn.net/20160620140312586" alt="img"></p>
<p>如上图，是一棵B+树。B+树的定义，童鞋可以自行百度，我们只说一些重点。图中浅蓝色的块，我们称之为一个磁盘，可以看到，每个磁盘块包含几个数据项（深蓝色）和指针（黄色）。如：磁盘块1包含数据17和数据35，包含指针P1,P2,P3，P1指向数据小于17的磁盘块，P2指向数据在17到35之间的数据所在磁盘块，P3指向数据大于35的数据所在的磁盘块。真实数据存在于叶子节点，即3，5，9，10，13，15，28，29，36，60，75，79，90，99 。 非叶子节点不存储真实数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p>
<p><strong>B+树的查找过程</strong></p>
<p>还是使用上面的B+树。假设，我们要查找数据项29，那么我们首先会把磁盘块1由磁盘加载到内存中，此时进行了一次I/O，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存计算时间由于非常短（对比于I/O）可以忽略不计，通过磁盘块1的P2指针的磁盘地址指向磁盘块3，由磁盘加载到内存，此时进行了第二次I/O，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，此时进行了第三次I/O，同时内存中计算二分查找找到29，查询结束。这一过程，一共进行了3次I/O。在真实使用场景中，三层的B+树可以表示上百万的数据，如果上百万的数据查询只需要三次I/O，性能提高将会是巨大的。B+树就是一种索引数据结构，如果没有这样的索引，每个数据项发生一次I/O，那么成本将会大大提升。</p>
<p><strong>B+树的性质</strong></p>
<p>在上面的查找例子中，我们可以分析出一些B+树的性质：</p>
<p>1，I/O的次数取决于B+树的高度H，假设当前数据表的数据为N，每个磁盘块的数据项的数量是M，则有：H=log(M+1)N，当数据量N一定的情况下，M越大，H越小；而M=磁盘块大小/数据项大小，磁盘块大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度也就越低。这也就是为什么每个数据项，即索引字段要尽量的小，比如int占4个字节，要比bigint的8个字节小一半。这也是为什么B+树要求把真实数据放在叶子节点内而不是内层节点内，一旦放到内层节点内，磁盘块的数据项会大幅度的下降，导致树层级的增高。当数据项为1时，B+树会退化成线性表。</p>
<p>2，B+树的数据项是复合性数据结构，比如（name，age，gender）的时候，B+树是按照从左到右的顺序来建立搜索树的，比如当（小张，22，女）这样的数据来检索的时候，B+树会优先比较name来确定下一步的搜索方向，如果name相同再依次比较age和gender，最后得到检索的数据。但是，当（22，女）这样没有name的数据来的时候，B+树就不知道下一步该查哪个节点，因为建立搜索树的时候，name就是第一个比较因子，必须根据name来搜索才知道下一步去哪里查询。比如，当（小张，男）这样的数据来检索时，B+树就可以根据name来指定搜索方向，但下一字段age缺失，所以只能把名字是“小张”的所有数据都找到，然后再匹配性别是“男”的数据了。这个是非常重要的一条性质，即索引的最左匹配特性。</p>
<h3 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h3><p>在MySQL中，索引分为两大类：聚簇索引和非聚簇索引。聚簇索引是按照数据存放的物理位置为顺序的，而非聚簇索引则不同；聚簇索引能够提高多行检索的速度，而非聚簇索引则对单行的检索速度很快。</p>
<p>在这两大类的索引类型下，还可以将索引分成四个小类：</p>
<p>1，普通索引：最基本的索引，没有任何限制，是我们大多数情况下使用到的索引。</p>
<p>2，唯一索引：与普通索引类型，不同的是唯一索引的列值必须唯一，但允许为空值。</p>
<p>3，全文索引：全文索引（FULLTEXT）仅可以适用于MyISAM引擎的数据表；作用于CHAR、VARCHAR、TEXT数据类型的列。</p>
<p>4，组合索引：将几个列作为一条索引进行检索，使用最左匹配原则。</p>
<p>1.添加PRIMARY KEY（主键索引）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` )</span><br></pre></td></tr></table></figure>

<p>2.添加UNIQUE(唯一索引) </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `table_name` ADD UNIQUE ( `column` )</span><br></pre></td></tr></table></figure>

<p>3.添加INDEX(普通索引) </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `table_name` ADD INDEX index_name ( `column` )</span><br></pre></td></tr></table></figure>

<p>4.添加FULLTEXT(全文索引) </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `table_name` ADD FULLTEXT ( `column`)</span><br></pre></td></tr></table></figure>

<p>5.添加多列索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )</span><br></pre></td></tr></table></figure>



<h3 id="建立索引的原则"><a href="#建立索引的原则" class="headerlink" title="建立索引的原则"></a>建立索引的原则</h3><p>我们回头来看一开始提到的慢查询，当我们了解完索引原理之后，对慢查询的优化应该有一些想法，这里我们先总结一下建立索引的一些原则：</p>
<h4 id="1，最左前缀匹配原则"><a href="#1，最左前缀匹配原则" class="headerlink" title="1，最左前缀匹配原则"></a>1，最左前缀匹配原则</h4><p>这是非常重要、非常重要、非常重要（重要的事情说三遍）的原则，MySQL会一直向右匹配直到遇到范围查询（&gt;,&lt;,BETWEEN,LIKE）就停止匹配，比如： a = 1 AND b = 2 AND c &gt; 3 AND d = 4，如果建立 （a,b,c,d）顺序的索引，d是用不到索引的，如果建立（a,b,d,c）的索引，则都可以用到，a,b,d的顺序可以任意调整。</p>
<h4 id="2，等于（-）和in-可以乱序"><a href="#2，等于（-）和in-可以乱序" class="headerlink" title="2，等于（=）和in 可以乱序"></a>2，等于（=）和in 可以乱序</h4><p>比如，a = 1 AND b = 2 AND c = 3 建立（a,b,c）索引可以任意顺序，MySQL的查询优化器会帮你优化成索引可以识别的模式。</p>
<h4 id="3，尽量选择区分度高的列作为索引"><a href="#3，尽量选择区分度高的列作为索引" class="headerlink" title="3，尽量选择区分度高的列作为索引"></a>3，尽量选择区分度高的列作为索引</h4><p>区分度的公式是 COUNT(DISTINCT col) / COUNT(*)。表示字段不重复的比率，比率越大我们扫描的记录数就越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度是0。可能有人会问，这个比率有什么经验么？使用场景不同，这个值也很难确定，一般需要JOIN的字段我们要求在0.1以上，即平均1条扫描10条记录。</p>
<h4 id="4，索引列不能参与计算，尽量保持列“干净”"><a href="#4，索引列不能参与计算，尽量保持列“干净”" class="headerlink" title="4，索引列不能参与计算，尽量保持列“干净”"></a>4，索引列不能参与计算，尽量保持列“干净”</h4><p>比如，FROM_UNIXTIME(create_time) = ‘2016-06-06’ 就不能使用索引，原因很简单，B+树中存储的都是数据表中的字段值，但是进行检索时，需要把所有元素都应用函数才能比较，显然这样的代价太大。所以语句要写成 ： create_time = UNIX_TIMESTAMP(‘2016-06-06’)。</p>
<h4 id="5，尽可能的扩展索引，不要新建立索引。"><a href="#5，尽可能的扩展索引，不要新建立索引。" class="headerlink" title="5，尽可能的扩展索引，不要新建立索引。"></a>5，尽可能的扩展索引，不要新建立索引。</h4><p>比如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。</p>
<p>6，单个多列组合索引和多个单列索引的检索查询效果不同，因为在执行SQL时，MySQL只能使用一个索引，会从多个单列索引中选择一个限制最为严格的索引<br>————————————————<br>版权声明：本文为CSDN博主「郭了个治浩」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/mysteryhaohao/article/details/51719871" target="_blank" rel="noopener">https://blog.csdn.net/mysteryhaohao/article/details/51719871</a></p>
<h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><h4 id="1-独立的列"><a href="#1-独立的列" class="headerlink" title="1. 独立的列"></a>1. 独立的列</h4><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p>
<p>例如下面的查询不能使用 actor_id 列的索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id + <span class="number">1</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-多列索引"><a href="#2-多列索引" class="headerlink" title="2. 多列索引"></a>2. 多列索引</h4><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, actor_ <span class="keyword">id</span> <span class="keyword">FROM</span> sakila.film_actor</span><br><span class="line"><span class="keyword">WHERE</span> actor_id = <span class="number">1</span> <span class="keyword">AND</span> film_id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-索引列的顺序"><a href="#3-索引列的顺序" class="headerlink" title="3. 索引列的顺序"></a>3. 索引列的顺序</h4><p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p>
<p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> staff_id)/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> staff_id_selectivity,</span><br><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> customer_id)/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> customer_id_selectivity,</span><br><span class="line"><span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> payment;</span><br><span class="line">   staff_id_selectivity: 0.0001</span><br><span class="line">customer_id_selectivity: 0.0373</span><br><span class="line">               COUNT(*): 16049</span><br></pre></td></tr></table></figure>

<h4 id="4-前缀索引"><a href="#4-前缀索引" class="headerlink" title="4. 前缀索引"></a>4. 前缀索引</h4><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p>
<p>前缀长度的选取需要根据索引选择性来确定。</p>
<h4 id="5-覆盖索引"><a href="#5-覆盖索引" class="headerlink" title="5. 覆盖索引"></a>5. 覆盖索引</h4><p>索引包含所有需要查询的字段的值。</p>
<p>具有以下优点：</p>
<ul>
<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>
<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>
<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/05/%E9%94%81%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/05/%E9%94%81%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">锁机制</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-05 10:21:39 / 修改时间：10:33:52" itemprop="dateCreated datePublished" datetime="2019-11-05T10:21:39+08:00">2019-11-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h3><p>数据的锁定分为两种，第一种叫作悲观锁，第二种叫作乐观锁。</p>
<p>1、悲观锁，就是对数据的冲突采取一种悲观的态度，也就是说假设数据肯定会冲突，所以在数据开始读取的时候就把数据锁定住。【数据锁定：数据将暂时不会得到修改】</p>
<p>2、乐观锁，认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让用户返回错误的信息。让用户决定如何去做。</p>
<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a><strong>理解</strong></h4><ol>
<li>乐观锁是一种思想，具体实现是，表中有一个版本字段，第一次读的时候，获取到这个字段。处理完业务逻辑开始更新的时候，需要再次查看该字段的值是否和第一次的一样。如果一样更新，反之拒绝。</li>
</ol>
<p>之所以叫乐观，因为这个模式没有从数据库加锁。</p>
<ol start="2">
<li>悲观锁是读取的时候为后面的更新加锁，之后再来的读操作都会等待。这种是数据库锁</li>
</ol>
<p>乐观锁优点程序实现，不会存在死锁等问题。他的适用场景也相对乐观。阻止不了除了程序之外的数据库操作。</p>
<p>悲观锁是数据库实现，他阻止一切数据库操作。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a><strong>实现</strong></h4><p>一、悲观锁<br>    1、排它锁，当事务在操作数据时把这部分数据进行锁定，直到操作完毕后再解锁，其他事务操作才可操作该部分数据。这将防止其他进程读取或修改表中的数据。</p>
<pre><code>2、实现：大多数情况下依靠数据库的锁机制实现

 一般使用 select ...for update 对所选择的数据进行加锁处理，例如select * from account where name=”Max” for update， 这条sql 语句锁定了account 表中所有符合检索条件（name=”Max”）的记录。本次事务提交之前（事务提交时会释放事务过程中的锁），外界无法修改这些记录。</code></pre><p>二、乐观锁<br>    1、如果有人在你之前更新了，你的更新应当是被拒绝的，可以让用户重新操作。</p>
<pre><code>2、实现：大多数基于数据版本（Version）记录机制实现

 具体可通过给表加一个版本号或时间戳字段实现，当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断当前版本信息与第一次取出来的版本值大小，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据，拒绝更新，让用户重新操作。</code></pre><h3 id="表级锁和行级锁"><a href="#表级锁和行级锁" class="headerlink" title="表级锁和行级锁"></a>表级锁和行级锁</h3><p>Mysql为了解决并发、数据安全的问题，使用了锁机制。</p>
<p>可以按照锁的粒度把数据库锁分为表级锁和行级锁。</p>
<pre><code>表级锁

Mysql中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单 ，资源消耗也比较少，加锁快，不会出现死锁 。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。

行级锁

Mysql中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。 InnoDB支持的行级锁，包括如下几种。
    Record Lock: 对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；
    Gap Lock: 对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。
    Next-key Lock： 锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题。</code></pre><p>虽然使用行级索具有粒度小、并发度高等特点，但是表级锁有时候也是非常必要的：</p>
<pre><code>事务更新大表中的大部分数据直接使用表级锁效率更高；
事务比较复杂，使用行级索很可能引起死锁导致回滚。</code></pre><p><strong>可以用以下方式避免死锁</strong></p>
<ul>
<li><strong>通过表级锁来减少死锁产生的概率；</strong></li>
<li><strong>多个程序尽量约定以相同的顺序访问表（这也是解决并发理论中哲学家就餐问题的一种思路）；</strong></li>
<li><strong>同一个事务尽可能做到一次锁定所需要的所有资源。</strong></li>
</ul>
<p><strong>表级锁和行级锁对比：</strong></p>
<ul>
<li><strong>表级锁：</strong> MySQL中锁定 <strong>粒度最大</strong> 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</li>
<li><strong>行级锁：</strong> MySQL中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。 </li>
</ul>
<h3 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h3><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB  存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用  MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><ul>
<li>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li>
<li>事务版本号：事务开始时的系统版本号。</li>
</ul>
<h4 id="隐藏的列"><a href="#隐藏的列" class="headerlink" title="隐藏的列"></a>隐藏的列</h4><p>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：</p>
<ul>
<li>创建版本号：指示创建一个数据行的快照时的系统版本号；</li>
<li>删除版本号：如果该快照的删除版本未定义或删除版本号大于当前事务版本号表示该快照有效</li>
</ul>
<h4 id="Undo-日志"><a href="#Undo-日志" class="headerlink" title="Undo 日志"></a>Undo 日志</h4><p>MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。</p>
<p> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e41405a8-7c05-4f70-8092-e961e28d3112.jpg" alt="img"> </p>
<h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>以下实现过程针对可重复读隔离级别。</p>
<p>当开始一个事务时，该事务的版本号肯定大于当前所有数据行快照的创建版本号，理解这一点很关键。数据行快照的创建版本号是创建数据行快照时的系统版本号，系统版本号随着创建事务而递增，因此新创建一个事务时，这个事务的系统版本号比之前的系统版本号都大，也就是比所有数据行快照的创建版本号都大。</p>
<h5 id="1-SELECT"><a href="#1-SELECT" class="headerlink" title="1. SELECT"></a>1. SELECT</h5><p>多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。</p>
<p>把没有对一个数据行做修改的事务称为  T，T 所要读取的数据行快照的创建版本号必须小于等于 T 的版本号，因为如果大于 T  的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。除此之外，T 所要读取的数据行快照的删除版本号必须是未定义或者大于 T  的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。</p>
<h5 id="2-INSERT"><a href="#2-INSERT" class="headerlink" title="2. INSERT"></a>2. INSERT</h5><p>将当前系统版本号作为数据行快照的创建版本号。</p>
<h5 id="3-DELETE"><a href="#3-DELETE" class="headerlink" title="3. DELETE"></a>3. DELETE</h5><p>将当前系统版本号作为数据行快照的删除版本号。</p>
<h5 id="4-UPDATE"><a href="#4-UPDATE" class="headerlink" title="4. UPDATE"></a>4. UPDATE</h5><p>将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。</p>
<h3 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h3><h4 id="1-快照读"><a href="#1-快照读" class="headerlink" title="1. 快照读"></a>1. 快照读</h4><p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> ...;</span><br></pre></td></tr></table></figure>

<h4 id="2-当前读"><a href="#2-当前读" class="headerlink" title="2. 当前读"></a>2. 当前读</h4><p>读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">insert</span>;</span><br><span class="line"><span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/04/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/04/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" class="post-title-link" itemprop="url">存储引擎</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-04 14:50:49 / 修改时间：14:51:42" itemprop="dateCreated datePublished" datetime="2019-11-04T14:50:49+08:00">2019-11-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文字描述 ：</p>
<p>Innodb引擎</p>
<p>Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。</p>
<p>MyISAM引擎</p>
<p>MyISAM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyISAM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyISAM也是很好的选择。<br>主要区别：</p>
<p>1、MyISAM是非事务安全的，而InnoDB是事务安全的</p>
<p>2、MyISAM锁的粒度是表级的，而InnoDB支持行级锁</p>
<p>3、MyISAM支持全文类型索引，而InnoDB不支持全文索引</p>
<p>4、MyISAM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyISAM</p>
<p>5、MyISAM表保存成文件形式，跨平台使用更加方便</p>
<p>怎样选择存储引擎</p>
<p>在实际工作中，选择一个合适的存储引擎是一个比较复杂的问题。每种存储引擎都有自己的优缺点，不能笼统地说谁比谁好。</p>
<p>应用场景：</p>
<p>InnoDB：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。 </p>
<p>MyISAM：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。</p>
<p>MEMORY：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。</p>
<p>注意，同一个数据库也可以使用多种存储引擎的表。如果一个表要求比较高的事务处理，可以选择InnoDB。这个数据库中可以将查询要求比较高的表选择MyISAM存储。如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎。</p>
<p>常用的两种引擎简单来说：</p>
<p>1、MyISAM管理非事务表，提供高速存储和检索以及全文搜索能力，如果再应用中执行大量select操作，应该选择MyISAM</p>
<p>2、InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，应该选择InnoDB</p>
<p>————————————————<br>版权声明：本文为CSDN博主「isxuran」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_21870555/article/details/82991660" target="_blank" rel="noopener">https://blog.csdn.net/qq_21870555/article/details/82991660</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="wingkywingky"
    src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">wingkywingky</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wingkywingky</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  
















  

  

</body>
</html>
