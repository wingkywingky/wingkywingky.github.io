<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Sagittarius">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="Sagittarius">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Sagittarius</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sagittarius</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/05/%E9%80%92%E5%BD%92%E5%88%A0%E9%99%A4%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/05/%E9%80%92%E5%BD%92%E5%88%A0%E9%99%A4%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">递归删除复制文件</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-05 10:58:44 / 修改时间：11:45:04" itemprop="dateCreated datePublished" datetime="2020-04-05T10:58:44+08:00">2020-04-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/" itemprop="url" rel="index">
                    <span itemprop="name">手撕代码</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>public static void deleteFile(File dir) {
        //1.获取文件夹下所有文件和文件夹
        File[] subFiles = dir.listFiles();
        //2.遍历数组
        for(File subFile : subFiles) {
            if(subFile.isFile()) {
                // 3.是文件就直接删除
                subFile.delete();
            }else {
                //4.书文件夹就递归删除
                deleteFile(subFile);
            }
        }
        //5.删除最外层文件夹
        dir.delete();
    }

public static void copy(File src, File dest) throws IOException {
    //1.在目标文件夹中创建原文件夹
    File newDir = new File(dest,src.getName());
    newDir.mkdir();
    //2.获取源文件夹中所有的文件和文件夹
    File[] subFiles = src.listFiles();
    //3.遍历数组
    for(File subFile : subFiles) {
        if(subFile.isFile()) {
            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(subFile));
            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(new File(newDir,subFile.getName())));
            int b;
            while((b = bis.read())!=-1) {
                bos.write(b);
            }
            bis.close();
            bos.close();
        }else {
            //4是文件夹就递归
            copy(subFile, newDir);
        }
    }
}</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%88%E5%90%8E%E9%81%8D%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%88%E5%90%8E%E9%81%8D%E5%8E%86/" class="post-title-link" itemprop="url">二叉树先后遍历</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-05 10:57:55 / 修改时间：11:45:26" itemprop="dateCreated datePublished" datetime="2020-04-05T10:57:55+08:00">2020-04-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/" itemprop="url" rel="index">
                    <span itemprop="name">手撕代码</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>二叉树先序遍历，非递归

public class Solution {
    public ArrayList&lt;Integer&gt; preorderTraversal(TreeNode root) {
        ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;();
        if(root==null){
            return arr;
        }

        Stack&lt;TreeNode&gt; s = new Stack&lt;TreeNode&gt;();
        s.push(root);
        TreeNode cur=null;
        while(!s.isEmpty()){
            cur=s.pop();
            if(cur!=null){
                arr.add(cur.val);
            s.push(cur.right);
            s.push(cur.left);
            }

        }
        return arr;
    }
}



二叉树后序遍历，非递归
public class Solution {
    public ArrayList&lt;Integer&gt; postorderTraversal(TreeNode root) {
        ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;();
        if(root==null){
            return arr;
        }
        Stack&lt;TreeNode&gt; s = new Stack&lt;TreeNode&gt;();
        s.push(root);
        TreeNode pre = null;
        while(!s.isEmpty()){
            TreeNode cur = s.peek();
            if((cur.left==null&amp;&amp;cur.right==null)||(pre!=null&amp;&amp;(pre==cur.left||pre==cur.right))){
                arr.add(cur.val);
                s.pop();
                pre=cur;
            }else{
                if(cur.right!=null){
                    s.push(cur.right);
                }
                if(cur.left!=null){
                    s.push(cur.left);
            }
        }
    }
        return arr;
    }

}</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/05/%E6%89%8B%E5%86%99%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/05/%E6%89%8B%E5%86%99%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">手写容器</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-05 10:57:30 / 修改时间：11:45:19" itemprop="dateCreated datePublished" datetime="2020-04-05T10:57:30+08:00">2020-04-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/" itemprop="url" rel="index">
                    <span itemprop="name">手撕代码</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code> * 实现一个容器，提供两个方法，add，size
 * 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到达5时，线程2给出提示并结束
 */
public class MyContainer3 {
private List&lt;Object&gt; list = new ArrayList&lt;&gt;();

public void add(Object ele) {
    list.add(ele);
}

public int size() {
    return list.size();
}

public static void main(String[] args) {

    MyContainer3 container = new MyContainer3();

    final Object lock = new Object();

    new Thread(() -&gt; {
        synchronized (lock) {
            System.out.println(&quot;t2 启动&quot;);
            if (container.size() != 5) {
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(&quot;监测到容器长度为5，线程2立即退出&quot;);
            lock.notify();
        }
    }, &quot;t2&quot;).start();

    // 先启动t2线程，让t2线程进入等待状态
    try {
        TimeUnit.SECONDS.sleep(2);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    new Thread(() -&gt; {
        synchronized (lock) {
            for (int i = 0; i &lt; 10; i++) {
                container.add(new Object());
                System.out.println(&quot;add &quot; + i);
                // 当长度为5时，通知 t2 进行退出
                if (container.size() == 5) {
                    lock.notify(); // notify 不会释放锁，即便通知t2，t2也获取不到锁
                    // 可以在wait一下，将锁释放，再让t2通知t1继续执行
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }, &quot;t1&quot;).start();
}
}



/*

使用wait和notify

wait()与notify() 方法的调用必须在同步代码块中
wait会释放锁，notify不会释放锁

锁定对象a，调用a.wait() 方法，当前线程就会进入等待状态，然后释放锁。
当某线程调用 a.notify() / a.notifyAll()， 叫醒在a对象等待的所有线程











 * 实现一个容器，提供两个方法，add，size
 * 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到达5时，线程2给出提示并结束
 */
public class MyContainer5 {
private volatile List&lt;Object&gt; list = new ArrayList&lt;&gt;();

public void add(Object ele) {
    list.add(ele);
}

public int size() {
    return list.size();
}

public static void main(String[] args) {

    MyContainer5 container = new MyContainer5();

    // Count down 往下数  Latch 门闩
    // 门闩不能保证可见性，不是一种同步方式，只是一种线程通信方式，保证不了可见性
    // 门闩的等待，不会持有任何锁
    CountDownLatch latch = new CountDownLatch(1);

    new Thread(() -&gt; {
        System.out.println(&quot;t2 启动&quot;);
        if (container.size() != 5) {
            try {
                latch.await();
                // 指定等待时间
                //latch.await(5000, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(&quot;监测到容器长度为5，线程2立即退出&quot;);
    }, &quot;t2&quot;).start();

    try {
        TimeUnit.SECONDS.sleep(1);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    new Thread(() -&gt; {
        System.out.println(&quot;t1 启动&quot;);
        for (int i = 0; i &lt; 10; i++) {
            container.add(new Object());
            System.out.println(&quot;add &quot; + i);
            // 当长度为5时，撤掉一个门闩，此时门闩为0，门会打开，即t2会执行
            if (container.size() == 5) {
                latch.countDown();
            }
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }, &quot;t1&quot;).start();
}
}

/*

使用CountDownLatch实现（最简单的方式）

Latch：门闩

使用Latch替代 wait notify来进行通信
好处是，通信简单，同时也可以指定等待时间
使用await和countDown 方法替代 wait 和 notify
CountDownLatch不涉及锁定，当count值为0时，当前线程继续运行
当不涉及同步，只涉及线程通信的时候，用synchronized + wait + notify 就显得太重了
 */</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/09/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/09/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">工厂模式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-09 16:05:38 / 修改时间：16:06:56" itemprop="dateCreated datePublished" datetime="2020-03-09T16:05:38+08:00">2020-03-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>工厂顾名思义就是创建产品，根据产品是具体产品还是具体工厂可分为简单工厂模式和工厂方法模式，根据工厂的抽象程度可分为工厂方法模式和抽象工厂模式。该模式用于封装和管理对象的创建，是一种创建型模式。本文从一个具体的例子逐步深入分析，来体会三种工厂模式的应用场景和利弊。</p>
<h3 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1. 简单工厂模式"></a>1. 简单工厂模式</h3><p>该模式对对象创建管理方式最为简单，因为其仅仅简单的对不同类对象的创建进行了一层薄薄的封装。该模式通过向工厂传递类型来指定要创建的对象，其UML类图如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/1419489/201906/1419489-20190628144601084-563759643.png" alt="img"></p>
<p>下面我们使用手机生产来讲解该模式：</p>
<p><strong>Phone类</strong>：手机标准规范类(AbstractProduct)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Phone &#123;</span><br><span class="line">    void make();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>MiPhone类</strong>：制造小米手机（Product1）</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MiPhone implements Phone &#123;</span><br><span class="line">    public MiPhone() &#123;</span><br><span class="line">        this.make();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void make() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        System.out.println(&quot;make xiaomi phone!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>IPhone类</strong>：制造苹果手机（Product2）</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class IPhone implements Phone &#123;</span><br><span class="line">    public IPhone() &#123;</span><br><span class="line">        this.make();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void make() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        System.out.println(&quot;make iphone!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>PhoneFactory类</strong>：手机代工厂（Factory）</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class PhoneFactory &#123;</span><br><span class="line">    public Phone makePhone(String phoneType) &#123;</span><br><span class="line">        if(phoneType.equalsIgnoreCase(&quot;MiPhone&quot;))&#123;</span><br><span class="line">            return new MiPhone();</span><br><span class="line">        &#125;</span><br><span class="line">        else if(phoneType.equalsIgnoreCase(&quot;iPhone&quot;)) &#123;</span><br><span class="line">            return new IPhone();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p> <strong>演示：</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] arg) &#123;</span><br><span class="line">        PhoneFactory factory = new PhoneFactory();</span><br><span class="line">        Phone miPhone = factory.makePhone(&quot;MiPhone&quot;);            // make xiaomi phone!</span><br><span class="line">        IPhone iPhone = (IPhone)factory.makePhone(&quot;iPhone&quot;);    // make iphone!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h3 id="2-工厂方法模式-Factory-Method"><a href="#2-工厂方法模式-Factory-Method" class="headerlink" title="2. 工厂方法模式(Factory Method)"></a>2. 工厂方法模式(Factory Method)</h3><p>和简单工厂模式中工厂负责生产所有产品相比，工厂方法模式将生成具体产品的任务分发给具体的产品工厂，其UML类图如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/1419489/201906/1419489-20190628154133368-906051111.png" alt="img"></p>
<p>也就是定义一个抽象工厂，其定义了产品的生产接口，但不负责具体的产品，将生产任务交给不同的派生类工厂。这样不用通过指定类型来创建对象了。</p>
<p>接下来继续使用生产手机的例子来讲解该模式。</p>
<p>其中和产品相关的Phone类、MiPhone类和IPhone类的定义不变。</p>
<p><strong>AbstractFactory类</strong>：生产不同产品的工厂的抽象类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface AbstractFactory &#123;</span><br><span class="line">    Phone makePhone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>XiaoMiFactory类</strong>：生产小米手机的工厂（ConcreteFactory1）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class XiaoMiFactory implements AbstractFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Phone makePhone() &#123;</span><br><span class="line">        return new MiPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AppleFactory类</strong>：生产苹果手机的工厂（ConcreteFactory2）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class AppleFactory implements AbstractFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Phone makePhone() &#123;</span><br><span class="line">        return new IPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>演示：</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] arg) &#123;</span><br><span class="line">        AbstractFactory miFactory = new XiaoMiFactory();</span><br><span class="line">        AbstractFactory appleFactory = new AppleFactory();</span><br><span class="line">        miFactory.makePhone();            // make xiaomi phone!</span><br><span class="line">        appleFactory.makePhone();        // make iphone!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h3 id="3-抽象工厂模式-Abstract-Factory"><a href="#3-抽象工厂模式-Abstract-Factory" class="headerlink" title="3. 抽象工厂模式(Abstract Factory)"></a>3. 抽象工厂模式(Abstract Factory)</h3><p>上面两种模式不管工厂怎么拆分抽象，都只是针对一类产品<strong>Phone</strong>（AbstractProduct），如果要生成另一种产品PC，应该怎么表示呢？</p>
<p>最简单的方式是把2中介绍的工厂方法模式完全复制一份，不过这次生产的是PC。但同时也就意味着我们要完全复制和修改Phone生产管理的所有代码，显然这是一个笨办法，并不利于扩展和维护。</p>
<p>抽象工厂模式通过在AbstarctFactory中增加创建产品的接口，并在具体子工厂中实现新加产品的创建，当然前提是子工厂支持生产该产品。否则继承的这个接口可以什么也不干。</p>
<p>其UML类图如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/1419489/201906/1419489-20190628170705865-1781414242.png" alt="img"></p>
<p>从上面类图结构中可以清楚的看到如何在工厂方法模式中通过增加新产品接口来实现产品的增加的。</p>
<p>接下来我们继续通过小米和苹果产品生产的例子来解释该模式。</p>
<p>为了弄清楚上面的结构，我们使用具体的产品和工厂来表示上面的UML类图，能更加清晰的看出模式是如何演变的：</p>
<p><img src="https://img2018.cnblogs.com/blog/1419489/201906/1419489-20190628164001258-637961514.png" alt="img"></p>
<p><strong>PC类</strong>：定义PC产品的接口(AbstractPC)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface PC &#123;</span><br><span class="line">    void make();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MiPC类</strong>：定义小米电脑产品(MIPC)</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MiPC implements PC &#123;</span><br><span class="line">    public MiPC() &#123;</span><br><span class="line">        this.make();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void make() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        System.out.println(&quot;make xiaomi PC!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>MAC类</strong>：定义苹果电脑产品(MAC)</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MAC implements PC &#123;</span><br><span class="line">    public MAC() &#123;</span><br><span class="line">        this.make();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void make() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        System.out.println(&quot;make MAC!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>下面需要修改工厂相关的类的定义：</p>
<p><strong>AbstractFactory类</strong>：增加PC产品制造接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface AbstractFactory &#123;</span><br><span class="line">    Phone makePhone();</span><br><span class="line">    PC makePC();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>XiaoMiFactory类</strong>：增加小米PC的制造（ConcreteFactory1）</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class XiaoMiFactory implements AbstractFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Phone makePhone() &#123;</span><br><span class="line">        return new MiPhone();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public PC makePC() &#123;</span><br><span class="line">        return new MiPC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>AppleFactory类</strong>：增加苹果PC的制造（ConcreteFactory2）</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class AppleFactory implements AbstractFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Phone makePhone() &#123;</span><br><span class="line">        return new IPhone();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public PC makePC() &#123;</span><br><span class="line">        return new MAC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>演示：</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] arg) &#123;</span><br><span class="line">        AbstractFactory miFactory = new XiaoMiFactory();</span><br><span class="line">        AbstractFactory appleFactory = new AppleFactory();</span><br><span class="line">        miFactory.makePhone();            // make xiaomi phone!</span><br><span class="line">        miFactory.makePC();                // make xiaomi PC!</span><br><span class="line">        appleFactory.makePhone();        // make iphone!</span><br><span class="line">        appleFactory.makePC();            // make MAC!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>上面介绍的三种工厂模式有各自的应用场景，实际应用时能解决问题满足需求即可，可灵活变通，无所谓高级与低级。</p>
<p>此外无论哪种模式，由于可能封装了大量对象和工厂创建，新加产品需要修改已定义好的工厂相关的类，因此对于产品和工厂的扩展不太友好，利弊需要权衡一下。 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/09/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/09/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">单例模式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-09 15:59:33 / 修改时间：16:05:10" itemprop="dateCreated datePublished" datetime="2020-03-09T15:59:33+08:00">2020-03-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、什么是单例模式"><a href="#一、什么是单例模式" class="headerlink" title="一、什么是单例模式"></a>一、什么是单例模式</h2><p>单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。</p>
<p>许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</p>
<p><img src="https://images2018.cnblogs.com/blog/1002892/201809/1002892-20180912131026735-781767905.png" alt="img"></p>
<p><strong>单例的实现主要是通过以下两个步骤</strong>：</p>
<ol>
<li>将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；</li>
<li>在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。</li>
<li></li>
</ol>
<h2 id="二、单例模式的应用场景"><a href="#二、单例模式的应用场景" class="headerlink" title="二、单例模式的应用场景"></a>二、单例模式的应用场景</h2><p>  举一个小例子，在我们的windows桌面上，我们打开了一个回收站，当我们试图再次打开一个新的回收站时，Windows系统并不会为你弹出一个新的回收站窗口。，也就是说在整个系统运行的过程中，系统只维护一个回收站的实例。这就是一个典型的单例模式运用。</p>
<p>   继续说回收站，我们在实际使用中并不存在需要同时打开两个回收站窗口的必要性。假如我每次创建回收站时都需要消耗大量的资源，而每个回收站之间资源是共享的，那么在没有必要多次重复创建该实例的情况下，创建了多个实例，这样做就会给系统造成不必要的负担，造成资源浪费。</p>
<p>   再举一个例子，网站的计数器，一般也是采用单例模式实现，如果你存在多个计数器，每一个用户的访问都刷新计数器的值，这样的话你的实计数的值是难以同步的。但是如果采用单例模式实现就不会存在这样的问题，而且还可以避免线程安全问题。同样多线程的线程池的设计一般也是采用单例模式，这是由于线程池需要方便对池中的线程进行控制</p>
<p>  同样，对于一些应用程序的日志应用，或者web开发中读取配置文件都适合使用单例模式，如HttpApplication 就是单例的典型应用。</p>
<p>  从上述的例子中我们可以总结出适合使用单例模式的场景和优缺点：  </p>
<p>   <strong>适用场景：</strong> </p>
<ul>
<li><strong>1.需要生成唯一序列的环境</strong></li>
<li><strong>2.需要频繁实例化然后销毁的对象。</strong></li>
<li><strong>3.创建对象时耗时过多或者耗资源过多，但又经常用到的对象。</strong> </li>
<li><strong>4.方便资源相互通信的环境</strong></li>
</ul>
<h2 id="三、单例模式的优缺点"><a href="#三、单例模式的优缺点" class="headerlink" title="三、单例模式的优缺点"></a>三、单例模式的优缺点</h2><p><strong>优点</strong>：</p>
<ul>
<li>在内存中只有一个对象，节省内存空间；</li>
<li>避免频繁的创建销毁对象，可以提高性能；</li>
<li>避免对共享资源的多重占用，简化访问；</li>
<li>为整个系统提供一个全局访问点。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>不适用于变化频繁的对象；</li>
<li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；</li>
<li>如果实例化的对象长时间不被利用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失；</li>
</ul>
<p><a href="https://www.cnblogs.com/xuwendong/p/9633985.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h2 id="四、单例模式的实现"><a href="#四、单例模式的实现" class="headerlink" title="四、单例模式的实现"></a>四、单例模式的实现</h2><h4 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1.饿汉式"></a><strong>1.饿汉式</strong></h4><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 饿汉式单例</span><br><span class="line">public class Singleton1 &#123;</span><br><span class="line"> </span><br><span class="line">    // 指向自己实例的私有静态引用，主动创建</span><br><span class="line">    private static Singleton1 singleton1 = new Singleton1();</span><br><span class="line"> </span><br><span class="line">    // 私有的构造方法</span><br><span class="line">    private Singleton1()&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    // 以自己实例为返回值的静态的公有方法，静态工厂方法</span><br><span class="line">    public static Singleton1 getSingleton1()&#123;</span><br><span class="line">        return singleton1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>我们知道，<strong>类加载的方式是按需加载，且加载一次</strong>。。因此，在上述单例类被加载时，就会实例化一个对象并交给自己的引用，供系统使用；而且，由于这个类在整个生命周期中只会被加载一次，因此只会创建一个实例，即能够充分保证单例。</p>
<p>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</p>
<p>缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。</p>
<h4 id="2-懒汉式"><a href="#2-懒汉式" class="headerlink" title="2.懒汉式"></a><strong>2.懒汉式</strong></h4><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 懒汉式单例</span><br><span class="line">public class Singleton2 &#123;</span><br><span class="line"> </span><br><span class="line">    // 指向自己实例的私有静态引用</span><br><span class="line">    private static Singleton2 singleton2;</span><br><span class="line"> </span><br><span class="line">    // 私有的构造方法</span><br><span class="line">    private Singleton2()&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    // 以自己实例为返回值的静态的公有方法，静态工厂方法</span><br><span class="line">    public static Singleton2 getSingleton2()&#123;</span><br><span class="line">        // 被动创建，在真正需要使用时才去创建</span><br><span class="line">        if (singleton2 == null) &#123;</span><br><span class="line">            singleton2 = new Singleton2();</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>我们从懒汉式单例可以看到，单例实例被<strong>延迟加载</strong>，即只有在真正使用的时候才会实例化一个对象并交给自己的引用。</p>
<p>这种写法起到了Lazy Loading的效果，但是只能在单线程下使用。如果在多线程下，一个线程进入了if (singleton ==  null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。</p>
<h4 id="3-双重加锁机制"><a href="#3-双重加锁机制" class="headerlink" title="3.双重加锁机制"></a><strong>3.双重加锁机制</strong></h4><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton</span><br><span class="line">    &#123;</span><br><span class="line">        private static Singleton instance;</span><br><span class="line">        //程序运行时创建一个静态只读的进程辅助对象</span><br><span class="line">        private static readonly object syncRoot = new object();</span><br><span class="line">        private Singleton() &#123; &#125;</span><br><span class="line">        public static Singleton GetInstance()</span><br><span class="line">        &#123;</span><br><span class="line">            //先判断是否存在，不存在再加锁处理</span><br><span class="line">            if (instance == null)</span><br><span class="line">            &#123;</span><br><span class="line">                //在同一个时刻加了锁的那部分程序只有一个线程可以进入</span><br><span class="line">                lock (syncRoot)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (instance == null)</span><br><span class="line">                    &#123;</span><br><span class="line">                        instance = new Singleton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>Double-Check概念对于多线程开发者来说不会陌生，如代码中所示，我们进行了两次if (singleton ==  null)检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton ==  null)，直接return实例化对象。</p>
<p>使用双重检测同步延迟加载去创建单例的做法是一个非常优秀的做法，<strong>其不但保证了单例，而且切实提高了程序运行效率</strong></p>
<p>优点：线程安全；延迟加载；效率较高。</p>
<h4 id="4-静态初始化"><a href="#4-静态初始化" class="headerlink" title="4.静态初始化"></a><strong>4.静态初始化</strong></h4><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//阻止发生派生，而派生可能会增加实例</span><br><span class="line">    public sealed class Singleton</span><br><span class="line">    &#123;</span><br><span class="line">        //在第一次引用类的任何成员时创建实例，公共语言运行库负责处理变量初始化</span><br><span class="line">        private static readonly Singleton instance=new Singleton();</span><br><span class="line">        </span><br><span class="line">        private Singleton() &#123; &#125;</span><br><span class="line">        public static Singleton GetInstance()</span><br><span class="line">        &#123;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>在实际应用中，C#与公共语言运行库也提供了一种“静态初始化”方法，这种方法不需要开发人员显式地编写线程安全代码，即可解决多线程环境下它是不安全的问题。</p>
<h4 id><a href="#" class="headerlink" title></a></h4><h4 id="5-静态内部类单例模式"><a href="#5-静态内部类单例模式" class="headerlink" title="5.静态内部类单例模式"></a><strong>5.静态内部类单例模式</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> Inner.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有第一次调用getInstance方法时，虚拟机才加载 Inner 并初始化instance ，只有一个线程可以获得对象的初始化锁，其他线程无法进行初始化，保证对象的唯一性。目前此方式是所有单例模式中最推荐的模式，但具体还是根据项目选择。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>当然，单例模式的实现方法还有很多。但是，这四种是比较经典的实现，也是我们应该掌握的几种实现方式。</p>
<p>从这四种实现中，我们可以总结出，要想实现效率高的线程安全的单例，我们必须注意以下两点：</p>
<ul>
<li><strong>尽量减少同步块的作用域；</strong></li>
<li><strong>尽量使用细粒度的锁。</strong></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/12/MYSQL%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/12/MYSQL%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">MYSQL优化相关</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-12 20:33:57 / 修改时间：21:20:06" itemprop="dateCreated datePublished" datetime="2019-11-12T20:33:57+08:00">2019-11-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h3><h4 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h4><p>如何发现有问题的SQL？使用mysql慢查询日志对有效率问题的SQL进行监控</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//查看慢查询日志是否开启</span><br><span class="line">show variables like &apos;slow_query_log&apos;;</span><br><span class="line"></span><br><span class="line">//查看慢查询日志存储位置</span><br><span class="line">show variables like &apos;slow_query_log_file&apos;;</span><br><span class="line"></span><br><span class="line">//开启慢查询日志</span><br><span class="line">set global slow_query_log=on;</span><br><span class="line"></span><br><span class="line">//指定慢查询日志存储位置</span><br><span class="line">set global show_query_log_file=&apos;/var/lib/mysql/homestead-slow.log&apos;;</span><br><span class="line"></span><br><span class="line">//记录没有使用索引的sql</span><br><span class="line">set global log_queries_not_using_indexes=on;</span><br><span class="line"></span><br><span class="line">//记录查询超过1s的sql</span><br><span class="line">set global long_query_time=1;</span><br></pre></td></tr></table></figure>

<p>慢查询日志所包含的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#User@Host:root[root] @localhost[]//执行sql的主机信息</span><br><span class="line">#Query_time:0.0000024 Lock_time:0.00 Rows_sent:0 Rows_esamined:0//sql的执行信息</span><br><span class="line">SET timestamp=1402389324//sql执行时间</span><br><span class="line">select * from store; //sql的内容</span><br></pre></td></tr></table></figure>

<p><strong>MySQL慢查询日志分析工具之mysqldumpslow（mysql官方）</strong></p>
<p>安装完MySQL后，默认就带了mysqldumpslow，很常用的一个工具。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//查看参数列表</span><br><span class="line">mysqldumpslow -h</span><br><span class="line"></span><br><span class="line">//分析慢查询日志中前三条比较慢的sql</span><br><span class="line">mysqldumpslow -t 3 /var/lib/mysql/homestead-slow.log | more </span><br><span class="line"></span><br><span class="line">//输出样式效果</span><br><span class="line">Count:1 Time:0.00s Lock=0.00s Rows=10.0</span><br><span class="line">root[rppt]@localhost</span><br><span class="line">select * from store</span><br></pre></td></tr></table></figure>

<p><strong>MySQL慢查询日志分析工具之pt-query-digest</strong></p>
<p>分析结果比mysqldumpslow更详细全面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//输出到文件</span><br><span class="line">pt-query-digest slow-log &gt; slow_log.report</span><br><span class="line"></span><br><span class="line">//输出到数据表</span><br><span class="line">pt-query-digest slow.log -review \</span><br><span class="line">    h=127.0.0.1,D=test,p=root,P=3306,u=root,t=query_review \</span><br><span class="line">    --create-reviewtable \</span><br><span class="line">    --review-history t=hostname_slow</span><br></pre></td></tr></table></figure>

<p>基本使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//查看参数列表</span><br><span class="line">pt-query-digest --help</span><br><span class="line"></span><br><span class="line">//分析慢查询日志中前三条比较慢的sql</span><br><span class="line">pt-query-digest /var/lib/mysql/homestead-slow.log | more </span><br><span class="line"></span><br><span class="line">//输出分为三部分</span><br><span class="line">1.显示除了日志的时间范围，以及总的sql数量和不同的sql数量</span><br><span class="line">2.Response Time:响应时间占比 Calls:sql执行次数</span><br><span class="line">3.sql的具体日志</span><br></pre></td></tr></table></figure>

<p>如何通过慢查询日志发现有问题的SQL？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.查询次数多且每次查询占用时间长的SQL</span><br><span class="line">通常为pt-query-digest分析的前几个查询</span><br><span class="line"></span><br><span class="line">2.IO大的SQL（数据库主要瓶颈出现在IO层次）</span><br><span class="line">注意pt-query-digest分析中的Rows examine项</span><br><span class="line"></span><br><span class="line">3.未命中索引的SQL</span><br><span class="line">注意pt-query-digest分析中的Rows examine和Rows Send的对比</span><br></pre></td></tr></table></figure>

<p>通过explain查询和分析SQL的执行计划</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">explain select customer_id,,first_name,last_name from customer;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Column 1</th>
<th>Column 2</th>
<th>Column 3</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td></td>
<td></td>
</tr>
<tr>
<td>select_type</td>
<td>SIMPLE</td>
<td></td>
</tr>
<tr>
<td>table</td>
<td>customer</td>
<td>该数据关于哪张表。</td>
</tr>
<tr>
<td>type</td>
<td>ALL</td>
<td>示连接使用了何种类型。从好到差const,eq_reg,ref,range,index和ALL。</td>
</tr>
<tr>
<td>possible_keys</td>
<td>NULL</td>
<td>可能应用在该表的索引，空，没有可能的索引。</td>
</tr>
<tr>
<td>key</td>
<td>NULL</td>
<td>实际使用的索引。空，没有使用索引。</td>
</tr>
<tr>
<td>key_len</td>
<td>NULL</td>
<td>使用的索引长度。不损失精度下，越短越好。</td>
</tr>
<tr>
<td>ref</td>
<td>NULL</td>
<td>显示索引的哪一列被使用了，常数。</td>
</tr>
<tr>
<td>rows</td>
<td>671</td>
<td>mysql认为必须检查的数据的行数。</td>
</tr>
<tr>
<td>Extra</td>
<td>‘</td>
<td>注意：Using filesort,Using tempoary</td>
</tr>
</tbody></table>
<h4 id="Count-和Max-的优化"><a href="#Count-和Max-的优化" class="headerlink" title="Count()和Max()的优化"></a>Count()和Max()的优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//查询最后支付时间--优化max()函数</span><br><span class="line">explain select max(payment_date) from payment;</span><br><span class="line">create index idx_paydate on payment(payment_data);//给payment_date建立索引(覆盖索引)</span><br><span class="line"></span><br><span class="line">//在一条SQL中同时查出2006年和2007年电影的数量--优化Count()函数</span><br><span class="line">select count(release_year=&apos;2006&apos; or null) as &apos;2006年电影数量&apos;，count(release_year=&apos;2007&apos; or null) as &apos;2007年电影数量&apos; from film;</span><br><span class="line">//有关count()函数</span><br><span class="line">https://blog.csdn.net/wendychiang1991/article/details/70909958/</span><br></pre></td></tr></table></figure>

<h4 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">通常情况下，需要把子查询优化为join查询，但在优化时要注意关联键是否有一对多的关系，要注意重复数据。(distinct去重)</span><br><span class="line">//查询sandra出演的所有影片</span><br><span class="line">explain select title,release_year,LENGTH from film</span><br><span class="line">where film_id in (</span><br><span class="line">select film_id from film_actor where actor_id in (</span><br><span class="line">select actor_id from actor where first_name=&apos;sandra&apos;));</span><br></pre></td></tr></table></figure>

<h4 id="group-by的优化"><a href="#group-by的优化" class="headerlink" title="group by的优化"></a>group by的优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//改前 临时表</span><br><span class="line">explain select actor.first_name,actor_last_name,count(*) from sakila.film_actor</span><br><span class="line">inner join sakila.actor USING(actor_id)</span><br><span class="line">group by film_actor.actor_id;</span><br><span class="line">//改后 结合子查询 索引</span><br><span class="line">explain select actor.first_name,actor.last_name,c.cnt from sakila.film_actor</span><br><span class="line">inner join (</span><br><span class="line">select actor_id,count(*) as cnt from sakila.film_actor group by actor_id) as c USING(actor_id);</span><br></pre></td></tr></table></figure>

<h4 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">limit常用于分页处理，时常会伴随order by 从句使用，因此大多时候会使用Filesorts这样会造成大量的IO问题。</span><br><span class="line"></span><br><span class="line">//文件排序，IO大</span><br><span class="line">explain select film_id,description from sakila.film order by title limit 50,5;</span><br><span class="line">1.优化：使用有索引的列或主键进行order by操作（order by film_id）</span><br><span class="line">2.记录上次返回的主键，在下次查询的时候用主键过滤，避免了数据量大时扫描过多的记录</span><br><span class="line">select film_id,description from sakila.film where film_if&gt;55 and film_id&lt;=60 order by film_id limit 1,5; </span><br><span class="line">页数越大，IO越大</span><br></pre></td></tr></table></figure>

<h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><h4 id="如何选择合适的列建立索引？"><a href="#如何选择合适的列建立索引？" class="headerlink" title="如何选择合适的列建立索引？"></a>如何选择合适的列建立索引？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.在where从句，group by从句，order by从句，on从句中出现的列(select)</span><br><span class="line">2.索引字段越小越好(表每页数据才会更多，IO效率会更高)</span><br><span class="line">3.离散度大的列放到联合索引的前面</span><br><span class="line">select * from payment where staff_id=2 and customer_id=584;</span><br><span class="line">index(staff_id,customer_id)好？还是index(customer_id,staff_id)好？</span><br><span class="line">由于customer_id的离散度更大(重复率小,可选择性更大)，所以应该使用index(customer_id,staff_id)</span><br></pre></td></tr></table></figure>

<h4 id="索引优化SQL的方法"><a href="#索引优化SQL的方法" class="headerlink" title="索引优化SQL的方法"></a>索引优化SQL的方法</h4><p>索引的维护及优化–重复及冗余索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">冗余索引是指多个索引的前缀列相同，或是在联合索引中包含了主键的索引。如下：key(name,id)就是一个冗余索引</span><br><span class="line">create table test(</span><br><span class="line">id int not null primary key,</span><br><span class="line">name varchar(10) not null,</span><br><span class="line">key(name,id)</span><br><span class="line">)engine=innodb;</span><br><span class="line">//可以删除冗余索引，达到优化效果。</span><br><span class="line"></span><br><span class="line">使用pt-duplicate-key-checker工具检查重复及冗余索引</span><br><span class="line">pt-duplicate-key-checker \</span><br><span class="line">-uroot \</span><br><span class="line">-p &apos;&apos; \</span><br><span class="line">-h 127.0.0.1</span><br></pre></td></tr></table></figure>

<p>索引维护的方法–删除不用索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">目前mysql中还没有记录索引的使用情况，但是在PerconMySQL和MariaDB中可通过INDEX_STATISTICS表来查看哪些索引未使用，但在mysql中目前只能通过慢查日志配合pt-index-usage工具来进行索引使用情况分析。</span><br><span class="line">pt-index-usage \</span><br><span class="line">    -uroot -p&apos;&apos; \</span><br><span class="line">    mysql-slow.log</span><br></pre></td></tr></table></figure>

<h3 id="数据库表结构优化"><a href="#数据库表结构优化" class="headerlink" title="数据库表结构优化"></a>数据库表结构优化</h3><h4 id="选择合适的数据类型"><a href="#选择合适的数据类型" class="headerlink" title="选择合适的数据类型"></a>选择合适的数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.使用可以存下你的数据的最小的数据类型</span><br><span class="line">2.使用简单的数据类型。int要比varchar类型在mysql处理上更简单</span><br><span class="line">3.尽可能的使用not null定义字段</span><br><span class="line">4.尽量少用text类型，非用不可时最好考虑分表</span><br><span class="line">*使用int来存储日志时间，利用FROM_UNIXTINE()(得到日期),UNIX_TIMESTAMP()(得到时间戳)两个函数来进行转换</span><br><span class="line">*使用bigint来存ip地址，利用INET_ATON(),INET_NTOA()两个函数来进行转换</span><br></pre></td></tr></table></figure>

<h4 id="表的范式化和反范式化"><a href="#表的范式化和反范式化" class="headerlink" title="表的范式化和反范式化"></a>表的范式化和反范式化</h4><p>范式化是指数据库设计的规范，目前说到范式化一般是指第三设计范式，也就是要求数据表中不存在非关键字段对任意候选关键字段的传递函数依赖则符合第三范式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">不符合第三范式要求的表存在下列问题：</span><br><span class="line">1.数据冗余：（分类，分类描述）对于每一个商品都会进行记录</span><br><span class="line">2.数据的插入异常</span><br><span class="line">3.数据的更新异常</span><br><span class="line">4.数据的删除异常</span><br></pre></td></tr></table></figure>

<p>反范式化是指为了查询效率的考虑把原本符合第三范式的表适当的增加冗余，以达到优化查询的目的，反范式化是一种以空间来换取时间的操作。</p>
<h4 id="表的拆分"><a href="#表的拆分" class="headerlink" title="表的拆分"></a>表的拆分</h4><p>垂直拆分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">所谓的垂直拆分，就是把原来一个有很多列的表拆分成多个表，这解决了表的宽度问题。通常垂直拆分可以按以下原则进行：</span><br><span class="line">1.把不常用的字段单独存放到一个表中</span><br><span class="line">2.把大字段独立存放到一个表中</span><br><span class="line">3.把经常一起使用的字段放到一起</span><br></pre></td></tr></table></figure>

<p>水平拆分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">表的水平拆分是为了解决单表的数据量过大的问题，水平拆分的表每一个表的结构都是完全一致的。</span><br><span class="line">常用的水平拆分方法为：</span><br><span class="line">1.对id进行hash运算，如果要拆分成5个表则使用mod(id,5)去除0-4个值</span><br><span class="line">2.针对不同的hashID把数据存到不同的表中</span><br></pre></td></tr></table></figure>

<p>转自<a href="https://www.zam9.com/blog/mysql_opt01#SQL%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96" target="_blank" rel="noopener">https://www.zam9.com/blog/mysql_opt01#SQL%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/11/%E6%AD%BB%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/11/%E6%AD%BB%E9%94%81/" class="post-title-link" itemprop="url">死锁</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-11 21:18:02 / 修改时间：21:21:09" itemprop="dateCreated datePublished" datetime="2019-11-11T21:18:02+08:00">2019-11-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/" itemprop="url" rel="index">
                    <span itemprop="name">手撕代码</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class DeadLockDome &#123;</span><br><span class="line"></span><br><span class="line">	private static String A = &quot;A&quot;;</span><br><span class="line"></span><br><span class="line">	private static String B = &quot;B&quot;;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new DeadLockDome().DeadLock();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private void DeadLock() &#123;</span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				// TODO Auto-generated method stub</span><br><span class="line">				synchronized (A) &#123;</span><br><span class="line">					System.out.println(&quot;获得A对象&quot;);</span><br><span class="line">					synchronized (B) &#123;</span><br><span class="line">						System.out.println(&quot;获得B对象&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				synchronized (B) &#123;</span><br><span class="line">					System.out.println(&quot;获得B对象&quot;);</span><br><span class="line">					synchronized (A) &#123;</span><br><span class="line">						System.out.println(&quot;获得A对象&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/11/%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/11/%E6%B3%9B%E5%9E%8B/" class="post-title-link" itemprop="url">泛型</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-11 15:40:12 / 修改时间：15:50:51" itemprop="dateCreated datePublished" datetime="2019-11-11T15:40:12+08:00">2019-11-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA基础</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p><strong>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</strong></p>
<p><strong>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）</strong>。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>
<h3 id="泛型的作用"><a href="#泛型的作用" class="headerlink" title="泛型的作用"></a>泛型的作用</h3><p>1，类型安全。 </p>
<pre><code>泛型的主要目标是提高 Java 程序的类型安全。编译时的强类型检查；通过知道使用泛型定义的变量的类型限制，编译器可以在一个高得多的程度上验证类型假设。没有泛型，这些假设就只存在于程序员的头脑中（或者如果幸运的话，还存在于代码注释中）。</code></pre><p>2，消除强制类型转换。 </p>
<pre><code>泛型的一个附带好处是，消除源代码中的许多强制类型转换。这使得代码更加可读，并且减少了出错机会。</code></pre><p>3，潜在的性能收益。 </p>
<pre><code>泛型为较大的优化带来可能。在泛型的初始实现中，编译器将强制类型转换（没有泛型的话，程序员会指定这些强制类型转换）插入生成的字节码中。但是更多类型信息可用于编译器这一事实，为未来版本的 JVM 的优化带来可能。由于泛型的实现方式，支持泛型（几乎）不需要 JVM 或类文件更改。所有工作都在编译器中完成，编译器生成类似于没有泛型（和强制类型转换）时所写的代码，只是更能确保类型安全而已。

 Java语言引入泛型的好处是安全简单。泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。</code></pre><p>4、更好的代码复用性，比如实现泛型算法</p>
<pre><code>在框架设计时候，BaseDao&lt;T&gt;、BaseService&lt;T&gt;、BaseDaoImpl&lt;T&gt;、BaseServiceImpl&lt;T&gt;；通过继承，实现抽象了所有公共方法，避免了每次都要写相同的代码。</code></pre><h3 id="使用泛型的注意事项"><a href="#使用泛型的注意事项" class="headerlink" title="使用泛型的注意事项"></a>使用泛型的注意事项</h3><p>1、泛型的类型参数只能是类类型（包括自定义类），不可以是简单类型。</p>
<pre><code>2、同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。

3、泛型的类型参数可以有多个。

4、泛型的参数类型可以使用extends语句，例如&lt;T extends superclass&gt;。习惯上成为“有界类型”。

5、泛型的参数类型还可以是通配符类型。例如Class&lt;?&gt; classType = Class.forName(Java.lang.String);</code></pre><h3 id="泛型的工作原理"><a href="#泛型的工作原理" class="headerlink" title="泛型的工作原理"></a>泛型的工作原理</h3><p> Java的泛型是伪泛型。在编译期间，所有的泛型信息都会被擦除掉。正确理解泛型概念的首要前提是理解类型擦出（type erasure）。</p>
<p>​       Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会在编译器在编译的时候去掉。这个过程就称为类型擦除。</p>
<p>​     如在代码中定义的List<object>和List<String>等类型，在编译后都会编程List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。</String></object></p>
<h3 id="泛型的使用方法"><a href="#泛型的使用方法" class="headerlink" title="泛型的使用方法"></a>泛型的使用方法</h3><p>（1）泛型类</p>
<p>泛型类也就是把泛型定义在类上，这样用户在使用类的时候才把类型给确定下来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectTool&lt;T&gt; &#123;</span><br><span class="line">    private T obj;</span><br><span class="line"></span><br><span class="line">    public T getObj() &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setObj(T obj) &#123;</span><br><span class="line">        this.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上面这个程序，在使用时如果定义了类型，那么在使用时就可以不用进行强制类型转换，直接就可以得到一个T类型的对象。</p>
<p>（2）泛型方法<br>有时候只关心某个方法，那么使用泛型时可以不定义泛型类，而是只定义一个泛型方法，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; void show(T t) &#123;</span><br><span class="line">       System.out.println(t);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>需要注意一下定义的格式，泛型必须得先定义才能够使用。</p>
<p>（3）继承关系<br>泛型类在继承时，可以明确父类（泛型类）的参数类型，也可以不明确。<br>现在我们有如下的泛型类<br>//泛型类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Inter&lt;T&gt; &#123;</span><br><span class="line">    public abstract void show(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>①明确类型<br>//在实现泛型类时明确父类的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class InterImpl implements Inter&lt;String&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show(String s) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②不明确类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class InterImpl&lt;T&gt; implements Inter&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void show(T t) &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/10/%E8%BE%93%E5%85%A5url%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/10/%E8%BE%93%E5%85%A5url%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/" class="post-title-link" itemprop="url">输入url发生什么</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-10 22:44:47 / 修改时间：22:51:33" itemprop="dateCreated datePublished" datetime="2019-11-10T22:44:47+08:00">2019-11-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>从开发&amp;运维角度方面来看，总体来说分为以下几个过程</p>
<ul>
<li>查找浏览器缓存</li>
<li>DNS 解析:将域名解析成 IP 地址</li>
<li>TCP 连接：TCP 三次握手</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>断开连接：TCP 四次挥手</li>
</ul>
<p>首先我们需要知道TCP/IP的网络模型，这里我就以四层模型为例子。</p>
<p>。</p>
<p><img src="http://images0.cnblogs.com/blog/622045/201507/020946547655321.png" alt="这里写图片描述"></p>
<p>第一步：在浏览器中输入<a href="http://www.baidu.com后，应用层会使用DNS解析域名，如果本地存有对应的IP，则使用；如果没有，则会向上级DNS服务器请求帮助，直至获得IP。域名解析详细过程会在下文讲到。" target="_blank" rel="noopener">www.baidu.com后，应用层会使用DNS解析域名，如果本地存有对应的IP，则使用；如果没有，则会向上级DNS服务器请求帮助，直至获得IP。域名解析详细过程会在下文讲到。</a></p>
<p>第二步：应用层将请求的信息装载入HTTP请求报文，信息包含了请求的方法（GET / POST）、目标url、遵循的协议（http / https / ftp…）等，然后应用层将发起HTTP请求。</p>
<p>第三步：传输层接收到应用层传递下来的数据，并分割成以报文段为单位的数据包进行管理，并为它们编号，方便服务器接收时能准确地还原报文信息。通过三次握手和目标端口建立安全通信。</p>
<p>第四步：网络层接收传输层传递的数据，根据IP通过ARP协议获得目标计算机物理地址—MAC。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标。</p>
<p>第五步：找到目标MAC地址以后，就将数据发送到数据链路层，这时开始真正的传输请求信息，传输完成以后请求结束。</p>
<p>第六步：服务器接收数据后，从下到上层层将数据解包，直到应用层。</p>
<p>第七步： 服务器接收到客户端发送的HTTP请求后，查找客户端请求的资源，将数据装载入响应报文并返回，响应报文中包括一个重要的信息——状态码，如200,404,500。<br>————————————————<br>版权声明：本文为CSDN博主「早就戒了」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_37169817/article/details/78663598" target="_blank" rel="noopener">https://blog.csdn.net/qq_37169817/article/details/78663598</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/10/TCP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/10/TCP/" class="post-title-link" itemprop="url">三次握手四次挥手</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-10 22:12:48 / 修改时间：22:37:43" itemprop="dateCreated datePublished" datetime="2019-11-10T22:12:48+08:00">2019-11-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="TCP报文（标准长度20字节）"><a href="#TCP报文（标准长度20字节）" class="headerlink" title="TCP报文（标准长度20字节）"></a>TCP报文（标准长度20字节）</h3><p><a href="https://a5223594.github.io/2019/09/25/传输层/20150611163052331.png" target="_blank" rel="noopener"><img src="https://a5223594.github.io/2019/09/25/%E4%BC%A0%E8%BE%93%E5%B1%82/20150611163052331.png" alt="TCP报文">TCP报文</a></p>
<p>TCP数据包每次能够传输的最大长度 = MTU(1500B) - IP头（20B）- TCP头（20B）= 1460Bytes。<br>源端口号与目的端口号：标识了发送方与接收方的地址，IP地址和端口号合称为套接字。</p>
<h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><ul>
<li>序列号和确认号：32位序列号与32位确认序号：序列号与确认号可以理解成两个通信进程在收发数据的时候互相应答的信息。比如说：A进程从序列号1000开始给B进程发送数据，发送五个数据。那么在B收到数据回复的时候，这里A的确认序列号应该是从1006，如果不是1006，比如说是1003，那就意味着1004、1005数据包B没有收到，于是A启动重发机制。这也就保证了数据的可靠性，也是TCP的特点之一。序列号是进程发送消息的号码，而确认号是期望目的进程返回的号码。进行比对，从而验证数据包是否到达。</li>
<li>4位TCP报头长度：这里的四位TCP报头长度，可以理解成四个比特位表示长度，四位比特位表示的值乘以四就是该TCP头部的长度。由图可知，报头最短长度为20字节，也就是说这里的四位TCP报头长度默认为0101。并且TCP报头长度不可超过15*4=60个字节。</li>
<li>标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：<br>URG：紧急指针（urgent pointer）有效；<br><strong>ACK</strong>：确认序号有效；<br>PSH：接收方应该尽快将这个报文交给应用层；<br>RST：重置连接；<br><strong>SYN</strong>：发起一个新连接；<br><strong>FIN</strong>：释放一个连接。</li>
<li>16位窗口大小：<strong>窗口大小标志着TCP缓冲区内部剩余空间的大小，起到一个流量控制的作用。如果窗口满了，那么这个时候是不允许数据接收的</strong>。后面到达的数据会被丢失。</li>
<li>16位校验和：这里的校验和由发送端填充，CRC校验。接收端校验数据的时候如果校验不通过，那么认为数据有问题。此处的校验和不仅仅校验TCP首部，还校验数据部分。</li>
<li>16位紧急指针：标识哪部分的数据为紧急数据。</li>
</ul>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。 三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 <code>connect()</code> 时。将触发三次握手。</p>
<ul>
<li>第一次握手(SYN=1, seq=x): 客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。 发送完毕后，客户端进入 <code>SYN_SEND</code> 状态。</li>
<li>第二次握手(SYN=1, ACK=1,  seq=y, ACKnum=x+1): 服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq  域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 <code>SYN_RCVD</code> 状态。</li>
<li>第三次握手(ACK=1，ACKnum=y+1) 客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1 发送完毕后，客户端进入 <code>ESTABLISHED</code> 状态，当服务器端接收到这个包时，也进入 <code>ESTABLISHED</code> 状态，TCP 握手结束。</li>
</ul>
<p>三次握手的过程的示意图如下：</p>
<p><img src="https://nipingd.github.io/assets/img/1567496958834.b9702e14.png" alt="1567496958834"></p>
<h4 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h4><p>为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。</p>
<h3 id="半连接、半打开、半关闭状态"><a href="#半连接、半打开、半关闭状态" class="headerlink" title="半连接、半打开、半关闭状态"></a>半连接、半打开、半关闭状态</h3><p>半连接状态：发生在TCP三次握手过程中，客户端向服务器发起连接，服务器也进行了回应，但是客户端却不进行第3次握手。</p>
<p>半打开状态：在TCP连接中，如果某一端关闭了连接或者是异常关闭，则该连接处于半打开状态。解决半打开问题：引入心跳机制就可以察觉半打开状态。</p>
<p>半关闭状态：当TCP链接中客户端向服务器发送 FIN 请求关闭，服务端回应ACK之后，并没有立即发送 FIN  给客户端，客户端就处于半关闭状态，此时客户端可以接收服务器发送的数据，但是客户端已经不能再向服务器发送数据。(应用层面，传输层服务端发送信号，客户端还是得发送响应)</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><a href="https://a5223594.github.io/2019/09/25/传输层/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" target="_blank" rel="noopener"><img src="https://a5223594.github.io/2019/09/25/%E4%BC%A0%E8%BE%93%E5%B1%82/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" alt="四次挥手">四次挥手</a></p>
<p>第一次挥手：Client发送一个FIN，Seq=K，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态；<br>第二次挥手：Server收到FIN后，发送一个ACK（K+1）给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态；<br>第三次挥手：Server发送一个FIN，Seq=L，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态；<br>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态（等待2MSL后关闭），接着发送一个ACK（L+1）给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p>
<h4 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"></a>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</h4><p>原因在于：首先FIN信号是由于调用close所以才发送的，而ACK是由内核发送的，所以ACK报文和FIN报文在发送的时间上都是分开的，不一定能同时发送。但是三次握手的时候发送SYN是由内核直接完成的，所以这就可以达到一个同步发送的情况。</p>
<h3 id="滑动窗口（流量控制）"><a href="#滑动窗口（流量控制）" class="headerlink" title="滑动窗口（流量控制）"></a>滑动窗口（流量控制）</h3><p>在确认应答机制中，对每一个发送的数据段，都要给一个ACK确认应答，收到ACK后再发送下一个数据段。这样做有一个比较大的缺点，就是性能较差。尤其是数据往返时间较长的时候。那么我们可不可以一次发送多个数据段呢：滑动窗口。<br>所谓的流量控制就是让发送方的发送速率不要太快，让接收方来得及接收。利用滑动窗口机制可以很方便的在TCP连接上实现对发送方的流量控制。</p>
<ul>
<li>接收端窗口rwnd（recv window）：接收端缓冲区大小。接收端将此窗口值放在 TCP 报文的首部中的窗口字段，传送给发送端；</li>
<li>拥塞窗口cwnd（congestion window）：发送端缓冲区大小；</li>
<li>发送窗口swnd（send window）：发送窗口的上限值 = Min [rwnd, cwnd]。</li>
</ul>
<p><a href="https://a5223594.github.io/2019/09/25/传输层/20180524132418928.png" target="_blank" rel="noopener"><img src="https://a5223594.github.io/2019/09/25/%E4%BC%A0%E8%BE%93%E5%B1%82/20180524132418928.png" alt="滑动窗口">滑动窗口</a></p>
<p><strong>滑动窗口内部的数据都是已经发送但是没有收到ACK应答的数据</strong>，滑动窗口<strong>左侧都是已经收到了ACK应答的数据</strong>，滑动窗口<strong>右侧是未发送的数据</strong>。</p>
<p>TCP协议规定，接收到三个重复的ACK响应，就开始重传响应所要求的报文的机制就是快重传速机制。<br>接收端ACK响应丢包其实对发送端发送的影响并不是那么大，后续的ACK响应能够处理好这个问题。</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>拥塞控制也就是考虑当前的网络环境，动态调整窗口大小，没有发生拥塞情况，则窗口增大，拥塞了窗口减小，如此往复，最终应该接近与接收端的窗口大小。</p>
<ol>
<li>慢启动和拥塞避免<br>在开始发送信息时，由于不知道具体的网络环境，为避免大量信息造成的拥塞现象，此时的拥塞窗口以最小值（即拥塞窗口和接收端窗口中的较小值）进行数据发送，并设定门限值作为慢启动算法和拥塞避免算法的分割点。慢启动是指以最小的拥塞窗口按照指数形式递增，达到门限值后，以拥塞避免算法，即线性递增方式增大拥塞窗口（这里递增时间间隔为一个往返时间RTT）。<br>在上述过程中，无论是窗口大小指数递增或者线性递增，当发生拥塞现象，则门限值更新为当前窗口大小的一半，拥塞窗口大小变为最小值，重复上述递增过程（此时属于网络环境限制，所以在接收端和拥塞窗口两个限制条件中选择拥塞窗口作为限制）。</li>
</ol>
<p><a href="https://a5223594.github.io/2019/09/25/传输层/20181028161235619.jpeg" target="_blank" rel="noopener"><img src="https://a5223594.github.io/2019/09/25/%E4%BC%A0%E8%BE%93%E5%B1%82/20181028161235619.jpeg" alt="拥塞控制">拥塞控制</a></p>
<ol>
<li>快重传和快恢复<br>当发送端连续收到三个重复的ack时，表示该数据段已经丢失，需要重发。当收到三个表示同一个数据段的ack时，不需要等待计时器超时，立即重新发送数据段（当时这三个ack要在超时之前到达发送端），因为能够收到接收端的ack确认信息，所以数据段只是单纯的丢失，而不是因为网络拥塞导致，所以此时不需要拥塞窗口更新为最小值进行慢启动（如果这样的话，反倒因为拥塞窗口的增长需要时间，可能导致性能降低），此时需要设置拥塞窗口大小为：门限值大小+3，当然此处的门限值已经更新为拥塞窗口值的一半大小，该行为也就是所谓的“乘法减少”，更新之后按照拥塞避免算法继续进行。</li>
<li>拥塞窗口大小为什么先以指数增加再以线性增加？<br>窗口大小首先以指数递增去探测一下网络的拥塞程度，执行拥塞避免算法后，拥塞窗口线性缓慢增大，防止网络过早出现拥塞。</li>
</ol>
<h3 id="粘包问题"><a href="#粘包问题" class="headerlink" title="粘包问题"></a>粘包问题</h3><p>TCP是基于字节流传输的，只维护发送出去多少，确认了多少，没有维护消息与消息之间的边界，因而可能导致粘包问题。<br>粘包问题本质上要在应用层维护消息与消息的边界。解决方案如下：</p>
<blockquote>
<p>在接收端接收的时候采用定长的方式接收；<br>在数据包尾添加一些分隔符；<br>在数据包头部加上数据包长度；<br>更复杂的应用层协议。</p>
</blockquote>
<h3 id="为什么udp不会粘包？"><a href="#为什么udp不会粘包？" class="headerlink" title="为什么udp不会粘包？"></a>为什么udp不会粘包？</h3><ol>
<li>TCP协议是面向流的协议，UDP是面向消息的协议<br>UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据</li>
<li>UDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样对于接收端来说就容易进行区分处理了。传输协议把数据当作一条独立的消息在网上传输，接收端只能接收独立的消息。接收端一次只能接收发送端发出的一个数据包,如果一次接受数据的大小小于发送端一次发送的数据大小，就会丢失一部分数据，即使丢失，接受端也不会分两次去接收</li>
</ol>
<h3 id="UDP-和-TCP-的特点"><a href="#UDP-和-TCP-的特点" class="headerlink" title="UDP 和 TCP 的特点"></a>UDP 和 TCP 的特点</h3><ul>
<li>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>传输控制协议  TCP（Transmission Control   Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条   TCP 连接只能是点对点的（一对一）。</li>
</ul>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP数据报最大长度64K（包含UDP首部），如果数据长度超过64K就需要在应用层手动分包，UDP无法保证包序，需要在应用层进行编号。</p>
<ul>
<li>特点</li>
</ul>
<ol>
<li>无连接：知道对端的IP和端口号就直接进行传输, 不需要建立连接。</li>
<li>不可靠：没有确认机制, 没有重传机制; 如果因为网络故障该段无法发到对方, UDP协议层也不会给应用层返回任何错误信息。</li>
<li>面向数据报：不能够灵活的控制读写数据的次数和数量，应用层交给UDP多长的报文, UDP原样发送, 既不会拆分, 也不会合并。</li>
<li>数据收不够灵活，但是能够明确区分两个数据包，避免粘包问题。</li>
</ol>
<ul>
<li><p>协议：</p>
<blockquote>
<p>NFS: 网络文件系统<br>TFTP: 简单文件传输协议<br>DHCP: 动态主机配置协议<br>BOOTP: 启动协议(用于无盘设备启动)<br>DNS: 域名解析协议</p>
</blockquote>
</li>
</ul>
<h3 id="基于-UDP-的几个例子"><a href="#基于-UDP-的几个例子" class="headerlink" title="基于 UDP 的几个例子"></a>基于 UDP 的几个例子</h3><ul>
<li>直播。直播对实时性的要求比较高，宁可丢包，也不要卡顿的，所以很多直播应用都基于 UDP 实现了自己的视频传输协议</li>
<li>实时游戏。游戏的特点也是实时性比较高，在这种情况下，采用自定义的可靠的 UDP 协议，自定义重传策略，能够把产生的延迟降到最低，减少网络问题对游戏造成的影响</li>
<li>物联网。一方面，物联网领域中断资源少，很可能知识个很小的嵌入式系统，而维护 TCP  协议的代价太大了；另一方面，物联网对实时性的要求也特别高。比如 Google 旗下的 Nest 简历 Thread  Group，推出了物联网通信协议 Thread，就是基于 UDP 协议的</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="wingkywingky"
    src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">wingkywingky</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wingkywingky</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  
















  

  

</body>
</html>
