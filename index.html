<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Sagittarius">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="Sagittarius">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Sagittarius</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sagittarius</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/13/%E6%9C%89%E8%BD%A6%E4%BB%A5%E5%90%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/13/%E6%9C%89%E8%BD%A6%E4%BB%A5%E5%90%8E/" class="post-title-link" itemprop="url">有车以后</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-13 17:04:32 / 修改时间：17:05:33" itemprop="dateCreated datePublished" datetime="2020-04-13T17:04:32+08:00">2020-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index">
                    <span itemprop="name">面试相关</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>hashmap怎么移除元素<br>LinkedHashMap 结构<br>currenthashmap怎么定位元素、扩容因子<br>redis实现分布式锁<br>redis拒绝策略<br>redis排行榜 注意事项<br>zookeeper选举机制<br>索引和不同数据库引擎<br>索引失效<br>索引类型、特点<br>存储过程<br>最左匹配原则<br>mq的工作模式<br>jvm什么时候fullGC 会有什么影响<br>jvm怎么划分老年代年轻代<br>java 线程池几种 注意事项<br>SpringBoot 线程 注入对象<br>Spring事务传播<br>Spring事务实现 场景<br>方法B植入事务 方法A调用会有影响吗<br>explain 字段type</p>
<p>面试前没做充足准备，主要是redis mq zookeeper 这一块没准备好，Spring 数据库方面也没发挥好</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/05/%E9%80%92%E5%BD%92%E5%88%A0%E9%99%A4%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/05/%E9%80%92%E5%BD%92%E5%88%A0%E9%99%A4%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">递归删除复制文件</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-05 10:58:44 / 修改时间：11:45:04" itemprop="dateCreated datePublished" datetime="2020-04-05T10:58:44+08:00">2020-04-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/" itemprop="url" rel="index">
                    <span itemprop="name">手撕代码</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>public static void deleteFile(File dir) {
        //1.获取文件夹下所有文件和文件夹
        File[] subFiles = dir.listFiles();
        //2.遍历数组
        for(File subFile : subFiles) {
            if(subFile.isFile()) {
                // 3.是文件就直接删除
                subFile.delete();
            }else {
                //4.书文件夹就递归删除
                deleteFile(subFile);
            }
        }
        //5.删除最外层文件夹
        dir.delete();
    }

public static void copy(File src, File dest) throws IOException {
    //1.在目标文件夹中创建原文件夹
    File newDir = new File(dest,src.getName());
    newDir.mkdir();
    //2.获取源文件夹中所有的文件和文件夹
    File[] subFiles = src.listFiles();
    //3.遍历数组
    for(File subFile : subFiles) {
        if(subFile.isFile()) {
            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(subFile));
            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(new File(newDir,subFile.getName())));
            int b;
            while((b = bis.read())!=-1) {
                bos.write(b);
            }
            bis.close();
            bos.close();
        }else {
            //4是文件夹就递归
            copy(subFile, newDir);
        }
    }
}</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%88%E5%90%8E%E9%81%8D%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%88%E5%90%8E%E9%81%8D%E5%8E%86/" class="post-title-link" itemprop="url">二叉树先后遍历</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-05 10:57:55 / 修改时间：11:45:26" itemprop="dateCreated datePublished" datetime="2020-04-05T10:57:55+08:00">2020-04-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/" itemprop="url" rel="index">
                    <span itemprop="name">手撕代码</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>二叉树先序遍历，非递归

public class Solution {
    public ArrayList&lt;Integer&gt; preorderTraversal(TreeNode root) {
        ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;();
        if(root==null){
            return arr;
        }

        Stack&lt;TreeNode&gt; s = new Stack&lt;TreeNode&gt;();
        s.push(root);
        TreeNode cur=null;
        while(!s.isEmpty()){
            cur=s.pop();
            if(cur!=null){
                arr.add(cur.val);
            s.push(cur.right);
            s.push(cur.left);
            }

        }
        return arr;
    }
}



二叉树后序遍历，非递归
public class Solution {
    public ArrayList&lt;Integer&gt; postorderTraversal(TreeNode root) {
        ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;();
        if(root==null){
            return arr;
        }
        Stack&lt;TreeNode&gt; s = new Stack&lt;TreeNode&gt;();
        s.push(root);
        TreeNode pre = null;
        while(!s.isEmpty()){
            TreeNode cur = s.peek();
            if((cur.left==null&amp;&amp;cur.right==null)||(pre!=null&amp;&amp;(pre==cur.left||pre==cur.right))){
                arr.add(cur.val);
                s.pop();
                pre=cur;
            }else{
                if(cur.right!=null){
                    s.push(cur.right);
                }
                if(cur.left!=null){
                    s.push(cur.left);
            }
        }
    }
        return arr;
    }

}</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/05/%E6%89%8B%E5%86%99%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/05/%E6%89%8B%E5%86%99%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">手写容器</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-05 10:57:30 / 修改时间：11:45:19" itemprop="dateCreated datePublished" datetime="2020-04-05T10:57:30+08:00">2020-04-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/" itemprop="url" rel="index">
                    <span itemprop="name">手撕代码</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code> * 实现一个容器，提供两个方法，add，size
 * 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到达5时，线程2给出提示并结束
 */
public class MyContainer3 {
private List&lt;Object&gt; list = new ArrayList&lt;&gt;();

public void add(Object ele) {
    list.add(ele);
}

public int size() {
    return list.size();
}

public static void main(String[] args) {

    MyContainer3 container = new MyContainer3();

    final Object lock = new Object();

    new Thread(() -&gt; {
        synchronized (lock) {
            System.out.println(&quot;t2 启动&quot;);
            if (container.size() != 5) {
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(&quot;监测到容器长度为5，线程2立即退出&quot;);
            lock.notify();
        }
    }, &quot;t2&quot;).start();

    // 先启动t2线程，让t2线程进入等待状态
    try {
        TimeUnit.SECONDS.sleep(2);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    new Thread(() -&gt; {
        synchronized (lock) {
            for (int i = 0; i &lt; 10; i++) {
                container.add(new Object());
                System.out.println(&quot;add &quot; + i);
                // 当长度为5时，通知 t2 进行退出
                if (container.size() == 5) {
                    lock.notify(); // notify 不会释放锁，即便通知t2，t2也获取不到锁
                    // 可以在wait一下，将锁释放，再让t2通知t1继续执行
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }, &quot;t1&quot;).start();
}
}



/*

使用wait和notify

wait()与notify() 方法的调用必须在同步代码块中
wait会释放锁，notify不会释放锁

锁定对象a，调用a.wait() 方法，当前线程就会进入等待状态，然后释放锁。
当某线程调用 a.notify() / a.notifyAll()， 叫醒在a对象等待的所有线程











 * 实现一个容器，提供两个方法，add，size
 * 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到达5时，线程2给出提示并结束
 */
public class MyContainer5 {
private volatile List&lt;Object&gt; list = new ArrayList&lt;&gt;();

public void add(Object ele) {
    list.add(ele);
}

public int size() {
    return list.size();
}

public static void main(String[] args) {

    MyContainer5 container = new MyContainer5();

    // Count down 往下数  Latch 门闩
    // 门闩不能保证可见性，不是一种同步方式，只是一种线程通信方式，保证不了可见性
    // 门闩的等待，不会持有任何锁
    CountDownLatch latch = new CountDownLatch(1);

    new Thread(() -&gt; {
        System.out.println(&quot;t2 启动&quot;);
        if (container.size() != 5) {
            try {
                latch.await();
                // 指定等待时间
                //latch.await(5000, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(&quot;监测到容器长度为5，线程2立即退出&quot;);
    }, &quot;t2&quot;).start();

    try {
        TimeUnit.SECONDS.sleep(1);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    new Thread(() -&gt; {
        System.out.println(&quot;t1 启动&quot;);
        for (int i = 0; i &lt; 10; i++) {
            container.add(new Object());
            System.out.println(&quot;add &quot; + i);
            // 当长度为5时，撤掉一个门闩，此时门闩为0，门会打开，即t2会执行
            if (container.size() == 5) {
                latch.countDown();
            }
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }, &quot;t1&quot;).start();
}
}

/*

使用CountDownLatch实现（最简单的方式）

Latch：门闩

使用Latch替代 wait notify来进行通信
好处是，通信简单，同时也可以指定等待时间
使用await和countDown 方法替代 wait 和 notify
CountDownLatch不涉及锁定，当count值为0时，当前线程继续运行
当不涉及同步，只涉及线程通信的时候，用synchronized + wait + notify 就显得太重了
 */</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/09/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/09/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">工厂模式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-09 16:05:38 / 修改时间：16:06:56" itemprop="dateCreated datePublished" datetime="2020-03-09T16:05:38+08:00">2020-03-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>工厂顾名思义就是创建产品，根据产品是具体产品还是具体工厂可分为简单工厂模式和工厂方法模式，根据工厂的抽象程度可分为工厂方法模式和抽象工厂模式。该模式用于封装和管理对象的创建，是一种创建型模式。本文从一个具体的例子逐步深入分析，来体会三种工厂模式的应用场景和利弊。</p>
<h3 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1. 简单工厂模式"></a>1. 简单工厂模式</h3><p>该模式对对象创建管理方式最为简单，因为其仅仅简单的对不同类对象的创建进行了一层薄薄的封装。该模式通过向工厂传递类型来指定要创建的对象，其UML类图如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/1419489/201906/1419489-20190628144601084-563759643.png" alt="img"></p>
<p>下面我们使用手机生产来讲解该模式：</p>
<p><strong>Phone类</strong>：手机标准规范类(AbstractProduct)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Phone &#123;</span><br><span class="line">    void make();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>MiPhone类</strong>：制造小米手机（Product1）</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MiPhone implements Phone &#123;</span><br><span class="line">    public MiPhone() &#123;</span><br><span class="line">        this.make();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void make() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        System.out.println(&quot;make xiaomi phone!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>IPhone类</strong>：制造苹果手机（Product2）</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class IPhone implements Phone &#123;</span><br><span class="line">    public IPhone() &#123;</span><br><span class="line">        this.make();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void make() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        System.out.println(&quot;make iphone!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>PhoneFactory类</strong>：手机代工厂（Factory）</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class PhoneFactory &#123;</span><br><span class="line">    public Phone makePhone(String phoneType) &#123;</span><br><span class="line">        if(phoneType.equalsIgnoreCase(&quot;MiPhone&quot;))&#123;</span><br><span class="line">            return new MiPhone();</span><br><span class="line">        &#125;</span><br><span class="line">        else if(phoneType.equalsIgnoreCase(&quot;iPhone&quot;)) &#123;</span><br><span class="line">            return new IPhone();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p> <strong>演示：</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] arg) &#123;</span><br><span class="line">        PhoneFactory factory = new PhoneFactory();</span><br><span class="line">        Phone miPhone = factory.makePhone(&quot;MiPhone&quot;);            // make xiaomi phone!</span><br><span class="line">        IPhone iPhone = (IPhone)factory.makePhone(&quot;iPhone&quot;);    // make iphone!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h3 id="2-工厂方法模式-Factory-Method"><a href="#2-工厂方法模式-Factory-Method" class="headerlink" title="2. 工厂方法模式(Factory Method)"></a>2. 工厂方法模式(Factory Method)</h3><p>和简单工厂模式中工厂负责生产所有产品相比，工厂方法模式将生成具体产品的任务分发给具体的产品工厂，其UML类图如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/1419489/201906/1419489-20190628154133368-906051111.png" alt="img"></p>
<p>也就是定义一个抽象工厂，其定义了产品的生产接口，但不负责具体的产品，将生产任务交给不同的派生类工厂。这样不用通过指定类型来创建对象了。</p>
<p>接下来继续使用生产手机的例子来讲解该模式。</p>
<p>其中和产品相关的Phone类、MiPhone类和IPhone类的定义不变。</p>
<p><strong>AbstractFactory类</strong>：生产不同产品的工厂的抽象类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface AbstractFactory &#123;</span><br><span class="line">    Phone makePhone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>XiaoMiFactory类</strong>：生产小米手机的工厂（ConcreteFactory1）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class XiaoMiFactory implements AbstractFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Phone makePhone() &#123;</span><br><span class="line">        return new MiPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AppleFactory类</strong>：生产苹果手机的工厂（ConcreteFactory2）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class AppleFactory implements AbstractFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Phone makePhone() &#123;</span><br><span class="line">        return new IPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>演示：</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] arg) &#123;</span><br><span class="line">        AbstractFactory miFactory = new XiaoMiFactory();</span><br><span class="line">        AbstractFactory appleFactory = new AppleFactory();</span><br><span class="line">        miFactory.makePhone();            // make xiaomi phone!</span><br><span class="line">        appleFactory.makePhone();        // make iphone!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h3 id="3-抽象工厂模式-Abstract-Factory"><a href="#3-抽象工厂模式-Abstract-Factory" class="headerlink" title="3. 抽象工厂模式(Abstract Factory)"></a>3. 抽象工厂模式(Abstract Factory)</h3><p>上面两种模式不管工厂怎么拆分抽象，都只是针对一类产品<strong>Phone</strong>（AbstractProduct），如果要生成另一种产品PC，应该怎么表示呢？</p>
<p>最简单的方式是把2中介绍的工厂方法模式完全复制一份，不过这次生产的是PC。但同时也就意味着我们要完全复制和修改Phone生产管理的所有代码，显然这是一个笨办法，并不利于扩展和维护。</p>
<p>抽象工厂模式通过在AbstarctFactory中增加创建产品的接口，并在具体子工厂中实现新加产品的创建，当然前提是子工厂支持生产该产品。否则继承的这个接口可以什么也不干。</p>
<p>其UML类图如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/1419489/201906/1419489-20190628170705865-1781414242.png" alt="img"></p>
<p>从上面类图结构中可以清楚的看到如何在工厂方法模式中通过增加新产品接口来实现产品的增加的。</p>
<p>接下来我们继续通过小米和苹果产品生产的例子来解释该模式。</p>
<p>为了弄清楚上面的结构，我们使用具体的产品和工厂来表示上面的UML类图，能更加清晰的看出模式是如何演变的：</p>
<p><img src="https://img2018.cnblogs.com/blog/1419489/201906/1419489-20190628164001258-637961514.png" alt="img"></p>
<p><strong>PC类</strong>：定义PC产品的接口(AbstractPC)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface PC &#123;</span><br><span class="line">    void make();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MiPC类</strong>：定义小米电脑产品(MIPC)</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MiPC implements PC &#123;</span><br><span class="line">    public MiPC() &#123;</span><br><span class="line">        this.make();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void make() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        System.out.println(&quot;make xiaomi PC!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>MAC类</strong>：定义苹果电脑产品(MAC)</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MAC implements PC &#123;</span><br><span class="line">    public MAC() &#123;</span><br><span class="line">        this.make();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void make() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        System.out.println(&quot;make MAC!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>下面需要修改工厂相关的类的定义：</p>
<p><strong>AbstractFactory类</strong>：增加PC产品制造接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface AbstractFactory &#123;</span><br><span class="line">    Phone makePhone();</span><br><span class="line">    PC makePC();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>XiaoMiFactory类</strong>：增加小米PC的制造（ConcreteFactory1）</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class XiaoMiFactory implements AbstractFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Phone makePhone() &#123;</span><br><span class="line">        return new MiPhone();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public PC makePC() &#123;</span><br><span class="line">        return new MiPC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>AppleFactory类</strong>：增加苹果PC的制造（ConcreteFactory2）</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class AppleFactory implements AbstractFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Phone makePhone() &#123;</span><br><span class="line">        return new IPhone();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public PC makePC() &#123;</span><br><span class="line">        return new MAC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>演示：</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] arg) &#123;</span><br><span class="line">        AbstractFactory miFactory = new XiaoMiFactory();</span><br><span class="line">        AbstractFactory appleFactory = new AppleFactory();</span><br><span class="line">        miFactory.makePhone();            // make xiaomi phone!</span><br><span class="line">        miFactory.makePC();                // make xiaomi PC!</span><br><span class="line">        appleFactory.makePhone();        // make iphone!</span><br><span class="line">        appleFactory.makePC();            // make MAC!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>上面介绍的三种工厂模式有各自的应用场景，实际应用时能解决问题满足需求即可，可灵活变通，无所谓高级与低级。</p>
<p>此外无论哪种模式，由于可能封装了大量对象和工厂创建，新加产品需要修改已定义好的工厂相关的类，因此对于产品和工厂的扩展不太友好，利弊需要权衡一下。 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/09/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/09/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">单例模式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-09 15:59:33 / 修改时间：16:05:10" itemprop="dateCreated datePublished" datetime="2020-03-09T15:59:33+08:00">2020-03-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、什么是单例模式"><a href="#一、什么是单例模式" class="headerlink" title="一、什么是单例模式"></a>一、什么是单例模式</h2><p>单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。</p>
<p>许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</p>
<p><img src="https://images2018.cnblogs.com/blog/1002892/201809/1002892-20180912131026735-781767905.png" alt="img"></p>
<p><strong>单例的实现主要是通过以下两个步骤</strong>：</p>
<ol>
<li>将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；</li>
<li>在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。</li>
<li></li>
</ol>
<h2 id="二、单例模式的应用场景"><a href="#二、单例模式的应用场景" class="headerlink" title="二、单例模式的应用场景"></a>二、单例模式的应用场景</h2><p>  举一个小例子，在我们的windows桌面上，我们打开了一个回收站，当我们试图再次打开一个新的回收站时，Windows系统并不会为你弹出一个新的回收站窗口。，也就是说在整个系统运行的过程中，系统只维护一个回收站的实例。这就是一个典型的单例模式运用。</p>
<p>   继续说回收站，我们在实际使用中并不存在需要同时打开两个回收站窗口的必要性。假如我每次创建回收站时都需要消耗大量的资源，而每个回收站之间资源是共享的，那么在没有必要多次重复创建该实例的情况下，创建了多个实例，这样做就会给系统造成不必要的负担，造成资源浪费。</p>
<p>   再举一个例子，网站的计数器，一般也是采用单例模式实现，如果你存在多个计数器，每一个用户的访问都刷新计数器的值，这样的话你的实计数的值是难以同步的。但是如果采用单例模式实现就不会存在这样的问题，而且还可以避免线程安全问题。同样多线程的线程池的设计一般也是采用单例模式，这是由于线程池需要方便对池中的线程进行控制</p>
<p>  同样，对于一些应用程序的日志应用，或者web开发中读取配置文件都适合使用单例模式，如HttpApplication 就是单例的典型应用。</p>
<p>  从上述的例子中我们可以总结出适合使用单例模式的场景和优缺点：  </p>
<p>   <strong>适用场景：</strong> </p>
<ul>
<li><strong>1.需要生成唯一序列的环境</strong></li>
<li><strong>2.需要频繁实例化然后销毁的对象。</strong></li>
<li><strong>3.创建对象时耗时过多或者耗资源过多，但又经常用到的对象。</strong> </li>
<li><strong>4.方便资源相互通信的环境</strong></li>
</ul>
<h2 id="三、单例模式的优缺点"><a href="#三、单例模式的优缺点" class="headerlink" title="三、单例模式的优缺点"></a>三、单例模式的优缺点</h2><p><strong>优点</strong>：</p>
<ul>
<li>在内存中只有一个对象，节省内存空间；</li>
<li>避免频繁的创建销毁对象，可以提高性能；</li>
<li>避免对共享资源的多重占用，简化访问；</li>
<li>为整个系统提供一个全局访问点。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>不适用于变化频繁的对象；</li>
<li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；</li>
<li>如果实例化的对象长时间不被利用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失；</li>
</ul>
<p><a href="https://www.cnblogs.com/xuwendong/p/9633985.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h2 id="四、单例模式的实现"><a href="#四、单例模式的实现" class="headerlink" title="四、单例模式的实现"></a>四、单例模式的实现</h2><h4 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1.饿汉式"></a><strong>1.饿汉式</strong></h4><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 饿汉式单例</span><br><span class="line">public class Singleton1 &#123;</span><br><span class="line"> </span><br><span class="line">    // 指向自己实例的私有静态引用，主动创建</span><br><span class="line">    private static Singleton1 singleton1 = new Singleton1();</span><br><span class="line"> </span><br><span class="line">    // 私有的构造方法</span><br><span class="line">    private Singleton1()&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    // 以自己实例为返回值的静态的公有方法，静态工厂方法</span><br><span class="line">    public static Singleton1 getSingleton1()&#123;</span><br><span class="line">        return singleton1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>我们知道，<strong>类加载的方式是按需加载，且加载一次</strong>。。因此，在上述单例类被加载时，就会实例化一个对象并交给自己的引用，供系统使用；而且，由于这个类在整个生命周期中只会被加载一次，因此只会创建一个实例，即能够充分保证单例。</p>
<p>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</p>
<p>缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。</p>
<h4 id="2-懒汉式"><a href="#2-懒汉式" class="headerlink" title="2.懒汉式"></a><strong>2.懒汉式</strong></h4><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 懒汉式单例</span><br><span class="line">public class Singleton2 &#123;</span><br><span class="line"> </span><br><span class="line">    // 指向自己实例的私有静态引用</span><br><span class="line">    private static Singleton2 singleton2;</span><br><span class="line"> </span><br><span class="line">    // 私有的构造方法</span><br><span class="line">    private Singleton2()&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    // 以自己实例为返回值的静态的公有方法，静态工厂方法</span><br><span class="line">    public static Singleton2 getSingleton2()&#123;</span><br><span class="line">        // 被动创建，在真正需要使用时才去创建</span><br><span class="line">        if (singleton2 == null) &#123;</span><br><span class="line">            singleton2 = new Singleton2();</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>我们从懒汉式单例可以看到，单例实例被<strong>延迟加载</strong>，即只有在真正使用的时候才会实例化一个对象并交给自己的引用。</p>
<p>这种写法起到了Lazy Loading的效果，但是只能在单线程下使用。如果在多线程下，一个线程进入了if (singleton ==  null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。</p>
<h4 id="3-双重加锁机制"><a href="#3-双重加锁机制" class="headerlink" title="3.双重加锁机制"></a><strong>3.双重加锁机制</strong></h4><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton</span><br><span class="line">    &#123;</span><br><span class="line">        private static Singleton instance;</span><br><span class="line">        //程序运行时创建一个静态只读的进程辅助对象</span><br><span class="line">        private static readonly object syncRoot = new object();</span><br><span class="line">        private Singleton() &#123; &#125;</span><br><span class="line">        public static Singleton GetInstance()</span><br><span class="line">        &#123;</span><br><span class="line">            //先判断是否存在，不存在再加锁处理</span><br><span class="line">            if (instance == null)</span><br><span class="line">            &#123;</span><br><span class="line">                //在同一个时刻加了锁的那部分程序只有一个线程可以进入</span><br><span class="line">                lock (syncRoot)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (instance == null)</span><br><span class="line">                    &#123;</span><br><span class="line">                        instance = new Singleton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>Double-Check概念对于多线程开发者来说不会陌生，如代码中所示，我们进行了两次if (singleton ==  null)检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton ==  null)，直接return实例化对象。</p>
<p>使用双重检测同步延迟加载去创建单例的做法是一个非常优秀的做法，<strong>其不但保证了单例，而且切实提高了程序运行效率</strong></p>
<p>优点：线程安全；延迟加载；效率较高。</p>
<h4 id="4-静态初始化"><a href="#4-静态初始化" class="headerlink" title="4.静态初始化"></a><strong>4.静态初始化</strong></h4><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//阻止发生派生，而派生可能会增加实例</span><br><span class="line">    public sealed class Singleton</span><br><span class="line">    &#123;</span><br><span class="line">        //在第一次引用类的任何成员时创建实例，公共语言运行库负责处理变量初始化</span><br><span class="line">        private static readonly Singleton instance=new Singleton();</span><br><span class="line">        </span><br><span class="line">        private Singleton() &#123; &#125;</span><br><span class="line">        public static Singleton GetInstance()</span><br><span class="line">        &#123;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>在实际应用中，C#与公共语言运行库也提供了一种“静态初始化”方法，这种方法不需要开发人员显式地编写线程安全代码，即可解决多线程环境下它是不安全的问题。</p>
<h4 id><a href="#" class="headerlink" title></a></h4><h4 id="5-静态内部类单例模式"><a href="#5-静态内部类单例模式" class="headerlink" title="5.静态内部类单例模式"></a><strong>5.静态内部类单例模式</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> Inner.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有第一次调用getInstance方法时，虚拟机才加载 Inner 并初始化instance ，只有一个线程可以获得对象的初始化锁，其他线程无法进行初始化，保证对象的唯一性。目前此方式是所有单例模式中最推荐的模式，但具体还是根据项目选择。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>当然，单例模式的实现方法还有很多。但是，这四种是比较经典的实现，也是我们应该掌握的几种实现方式。</p>
<p>从这四种实现中，我们可以总结出，要想实现效率高的线程安全的单例，我们必须注意以下两点：</p>
<ul>
<li><strong>尽量减少同步块的作用域；</strong></li>
<li><strong>尽量使用细粒度的锁。</strong></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/12/MYSQL%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/12/MYSQL%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">MYSQL优化相关</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-12 20:33:57 / 修改时间：21:20:06" itemprop="dateCreated datePublished" datetime="2019-11-12T20:33:57+08:00">2019-11-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h3><h4 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h4><p>如何发现有问题的SQL？使用mysql慢查询日志对有效率问题的SQL进行监控</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//查看慢查询日志是否开启</span><br><span class="line">show variables like &apos;slow_query_log&apos;;</span><br><span class="line"></span><br><span class="line">//查看慢查询日志存储位置</span><br><span class="line">show variables like &apos;slow_query_log_file&apos;;</span><br><span class="line"></span><br><span class="line">//开启慢查询日志</span><br><span class="line">set global slow_query_log=on;</span><br><span class="line"></span><br><span class="line">//指定慢查询日志存储位置</span><br><span class="line">set global show_query_log_file=&apos;/var/lib/mysql/homestead-slow.log&apos;;</span><br><span class="line"></span><br><span class="line">//记录没有使用索引的sql</span><br><span class="line">set global log_queries_not_using_indexes=on;</span><br><span class="line"></span><br><span class="line">//记录查询超过1s的sql</span><br><span class="line">set global long_query_time=1;</span><br></pre></td></tr></table></figure>

<p>慢查询日志所包含的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#User@Host:root[root] @localhost[]//执行sql的主机信息</span><br><span class="line">#Query_time:0.0000024 Lock_time:0.00 Rows_sent:0 Rows_esamined:0//sql的执行信息</span><br><span class="line">SET timestamp=1402389324//sql执行时间</span><br><span class="line">select * from store; //sql的内容</span><br></pre></td></tr></table></figure>

<p><strong>MySQL慢查询日志分析工具之mysqldumpslow（mysql官方）</strong></p>
<p>安装完MySQL后，默认就带了mysqldumpslow，很常用的一个工具。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//查看参数列表</span><br><span class="line">mysqldumpslow -h</span><br><span class="line"></span><br><span class="line">//分析慢查询日志中前三条比较慢的sql</span><br><span class="line">mysqldumpslow -t 3 /var/lib/mysql/homestead-slow.log | more </span><br><span class="line"></span><br><span class="line">//输出样式效果</span><br><span class="line">Count:1 Time:0.00s Lock=0.00s Rows=10.0</span><br><span class="line">root[rppt]@localhost</span><br><span class="line">select * from store</span><br></pre></td></tr></table></figure>

<p><strong>MySQL慢查询日志分析工具之pt-query-digest</strong></p>
<p>分析结果比mysqldumpslow更详细全面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//输出到文件</span><br><span class="line">pt-query-digest slow-log &gt; slow_log.report</span><br><span class="line"></span><br><span class="line">//输出到数据表</span><br><span class="line">pt-query-digest slow.log -review \</span><br><span class="line">    h=127.0.0.1,D=test,p=root,P=3306,u=root,t=query_review \</span><br><span class="line">    --create-reviewtable \</span><br><span class="line">    --review-history t=hostname_slow</span><br></pre></td></tr></table></figure>

<p>基本使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//查看参数列表</span><br><span class="line">pt-query-digest --help</span><br><span class="line"></span><br><span class="line">//分析慢查询日志中前三条比较慢的sql</span><br><span class="line">pt-query-digest /var/lib/mysql/homestead-slow.log | more </span><br><span class="line"></span><br><span class="line">//输出分为三部分</span><br><span class="line">1.显示除了日志的时间范围，以及总的sql数量和不同的sql数量</span><br><span class="line">2.Response Time:响应时间占比 Calls:sql执行次数</span><br><span class="line">3.sql的具体日志</span><br></pre></td></tr></table></figure>

<p>如何通过慢查询日志发现有问题的SQL？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.查询次数多且每次查询占用时间长的SQL</span><br><span class="line">通常为pt-query-digest分析的前几个查询</span><br><span class="line"></span><br><span class="line">2.IO大的SQL（数据库主要瓶颈出现在IO层次）</span><br><span class="line">注意pt-query-digest分析中的Rows examine项</span><br><span class="line"></span><br><span class="line">3.未命中索引的SQL</span><br><span class="line">注意pt-query-digest分析中的Rows examine和Rows Send的对比</span><br></pre></td></tr></table></figure>

<p>通过explain查询和分析SQL的执行计划</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">explain select customer_id,,first_name,last_name from customer;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Column 1</th>
<th>Column 2</th>
<th>Column 3</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td></td>
<td></td>
</tr>
<tr>
<td>select_type</td>
<td>SIMPLE</td>
<td></td>
</tr>
<tr>
<td>table</td>
<td>customer</td>
<td>该数据关于哪张表。</td>
</tr>
<tr>
<td>type</td>
<td>ALL</td>
<td>示连接使用了何种类型。从好到差const,eq_reg,ref,range,index和ALL。</td>
</tr>
<tr>
<td>possible_keys</td>
<td>NULL</td>
<td>可能应用在该表的索引，空，没有可能的索引。</td>
</tr>
<tr>
<td>key</td>
<td>NULL</td>
<td>实际使用的索引。空，没有使用索引。</td>
</tr>
<tr>
<td>key_len</td>
<td>NULL</td>
<td>使用的索引长度。不损失精度下，越短越好。</td>
</tr>
<tr>
<td>ref</td>
<td>NULL</td>
<td>显示索引的哪一列被使用了，常数。</td>
</tr>
<tr>
<td>rows</td>
<td>671</td>
<td>mysql认为必须检查的数据的行数。</td>
</tr>
<tr>
<td>Extra</td>
<td>‘</td>
<td>注意：Using filesort,Using tempoary</td>
</tr>
</tbody></table>
<h4 id="Count-和Max-的优化"><a href="#Count-和Max-的优化" class="headerlink" title="Count()和Max()的优化"></a>Count()和Max()的优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//查询最后支付时间--优化max()函数</span><br><span class="line">explain select max(payment_date) from payment;</span><br><span class="line">create index idx_paydate on payment(payment_data);//给payment_date建立索引(覆盖索引)</span><br><span class="line"></span><br><span class="line">//在一条SQL中同时查出2006年和2007年电影的数量--优化Count()函数</span><br><span class="line">select count(release_year=&apos;2006&apos; or null) as &apos;2006年电影数量&apos;，count(release_year=&apos;2007&apos; or null) as &apos;2007年电影数量&apos; from film;</span><br><span class="line">//有关count()函数</span><br><span class="line">https://blog.csdn.net/wendychiang1991/article/details/70909958/</span><br></pre></td></tr></table></figure>

<h4 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">通常情况下，需要把子查询优化为join查询，但在优化时要注意关联键是否有一对多的关系，要注意重复数据。(distinct去重)</span><br><span class="line">//查询sandra出演的所有影片</span><br><span class="line">explain select title,release_year,LENGTH from film</span><br><span class="line">where film_id in (</span><br><span class="line">select film_id from film_actor where actor_id in (</span><br><span class="line">select actor_id from actor where first_name=&apos;sandra&apos;));</span><br></pre></td></tr></table></figure>

<h4 id="group-by的优化"><a href="#group-by的优化" class="headerlink" title="group by的优化"></a>group by的优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//改前 临时表</span><br><span class="line">explain select actor.first_name,actor_last_name,count(*) from sakila.film_actor</span><br><span class="line">inner join sakila.actor USING(actor_id)</span><br><span class="line">group by film_actor.actor_id;</span><br><span class="line">//改后 结合子查询 索引</span><br><span class="line">explain select actor.first_name,actor.last_name,c.cnt from sakila.film_actor</span><br><span class="line">inner join (</span><br><span class="line">select actor_id,count(*) as cnt from sakila.film_actor group by actor_id) as c USING(actor_id);</span><br></pre></td></tr></table></figure>

<h4 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">limit常用于分页处理，时常会伴随order by 从句使用，因此大多时候会使用Filesorts这样会造成大量的IO问题。</span><br><span class="line"></span><br><span class="line">//文件排序，IO大</span><br><span class="line">explain select film_id,description from sakila.film order by title limit 50,5;</span><br><span class="line">1.优化：使用有索引的列或主键进行order by操作（order by film_id）</span><br><span class="line">2.记录上次返回的主键，在下次查询的时候用主键过滤，避免了数据量大时扫描过多的记录</span><br><span class="line">select film_id,description from sakila.film where film_if&gt;55 and film_id&lt;=60 order by film_id limit 1,5; </span><br><span class="line">页数越大，IO越大</span><br></pre></td></tr></table></figure>

<h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><h4 id="如何选择合适的列建立索引？"><a href="#如何选择合适的列建立索引？" class="headerlink" title="如何选择合适的列建立索引？"></a>如何选择合适的列建立索引？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.在where从句，group by从句，order by从句，on从句中出现的列(select)</span><br><span class="line">2.索引字段越小越好(表每页数据才会更多，IO效率会更高)</span><br><span class="line">3.离散度大的列放到联合索引的前面</span><br><span class="line">select * from payment where staff_id=2 and customer_id=584;</span><br><span class="line">index(staff_id,customer_id)好？还是index(customer_id,staff_id)好？</span><br><span class="line">由于customer_id的离散度更大(重复率小,可选择性更大)，所以应该使用index(customer_id,staff_id)</span><br></pre></td></tr></table></figure>

<h4 id="索引优化SQL的方法"><a href="#索引优化SQL的方法" class="headerlink" title="索引优化SQL的方法"></a>索引优化SQL的方法</h4><p>索引的维护及优化–重复及冗余索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">冗余索引是指多个索引的前缀列相同，或是在联合索引中包含了主键的索引。如下：key(name,id)就是一个冗余索引</span><br><span class="line">create table test(</span><br><span class="line">id int not null primary key,</span><br><span class="line">name varchar(10) not null,</span><br><span class="line">key(name,id)</span><br><span class="line">)engine=innodb;</span><br><span class="line">//可以删除冗余索引，达到优化效果。</span><br><span class="line"></span><br><span class="line">使用pt-duplicate-key-checker工具检查重复及冗余索引</span><br><span class="line">pt-duplicate-key-checker \</span><br><span class="line">-uroot \</span><br><span class="line">-p &apos;&apos; \</span><br><span class="line">-h 127.0.0.1</span><br></pre></td></tr></table></figure>

<p>索引维护的方法–删除不用索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">目前mysql中还没有记录索引的使用情况，但是在PerconMySQL和MariaDB中可通过INDEX_STATISTICS表来查看哪些索引未使用，但在mysql中目前只能通过慢查日志配合pt-index-usage工具来进行索引使用情况分析。</span><br><span class="line">pt-index-usage \</span><br><span class="line">    -uroot -p&apos;&apos; \</span><br><span class="line">    mysql-slow.log</span><br></pre></td></tr></table></figure>

<h3 id="数据库表结构优化"><a href="#数据库表结构优化" class="headerlink" title="数据库表结构优化"></a>数据库表结构优化</h3><h4 id="选择合适的数据类型"><a href="#选择合适的数据类型" class="headerlink" title="选择合适的数据类型"></a>选择合适的数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.使用可以存下你的数据的最小的数据类型</span><br><span class="line">2.使用简单的数据类型。int要比varchar类型在mysql处理上更简单</span><br><span class="line">3.尽可能的使用not null定义字段</span><br><span class="line">4.尽量少用text类型，非用不可时最好考虑分表</span><br><span class="line">*使用int来存储日志时间，利用FROM_UNIXTINE()(得到日期),UNIX_TIMESTAMP()(得到时间戳)两个函数来进行转换</span><br><span class="line">*使用bigint来存ip地址，利用INET_ATON(),INET_NTOA()两个函数来进行转换</span><br></pre></td></tr></table></figure>

<h4 id="表的范式化和反范式化"><a href="#表的范式化和反范式化" class="headerlink" title="表的范式化和反范式化"></a>表的范式化和反范式化</h4><p>范式化是指数据库设计的规范，目前说到范式化一般是指第三设计范式，也就是要求数据表中不存在非关键字段对任意候选关键字段的传递函数依赖则符合第三范式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">不符合第三范式要求的表存在下列问题：</span><br><span class="line">1.数据冗余：（分类，分类描述）对于每一个商品都会进行记录</span><br><span class="line">2.数据的插入异常</span><br><span class="line">3.数据的更新异常</span><br><span class="line">4.数据的删除异常</span><br></pre></td></tr></table></figure>

<p>反范式化是指为了查询效率的考虑把原本符合第三范式的表适当的增加冗余，以达到优化查询的目的，反范式化是一种以空间来换取时间的操作。</p>
<h4 id="表的拆分"><a href="#表的拆分" class="headerlink" title="表的拆分"></a>表的拆分</h4><p>垂直拆分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">所谓的垂直拆分，就是把原来一个有很多列的表拆分成多个表，这解决了表的宽度问题。通常垂直拆分可以按以下原则进行：</span><br><span class="line">1.把不常用的字段单独存放到一个表中</span><br><span class="line">2.把大字段独立存放到一个表中</span><br><span class="line">3.把经常一起使用的字段放到一起</span><br></pre></td></tr></table></figure>

<p>水平拆分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">表的水平拆分是为了解决单表的数据量过大的问题，水平拆分的表每一个表的结构都是完全一致的。</span><br><span class="line">常用的水平拆分方法为：</span><br><span class="line">1.对id进行hash运算，如果要拆分成5个表则使用mod(id,5)去除0-4个值</span><br><span class="line">2.针对不同的hashID把数据存到不同的表中</span><br></pre></td></tr></table></figure>

<p>转自<a href="https://www.zam9.com/blog/mysql_opt01#SQL%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96" target="_blank" rel="noopener">https://www.zam9.com/blog/mysql_opt01#SQL%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/11/%E6%AD%BB%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/11/%E6%AD%BB%E9%94%81/" class="post-title-link" itemprop="url">死锁</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-11 21:18:02 / 修改时间：21:21:09" itemprop="dateCreated datePublished" datetime="2019-11-11T21:18:02+08:00">2019-11-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/" itemprop="url" rel="index">
                    <span itemprop="name">手撕代码</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class DeadLockDome &#123;</span><br><span class="line"></span><br><span class="line">	private static String A = &quot;A&quot;;</span><br><span class="line"></span><br><span class="line">	private static String B = &quot;B&quot;;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new DeadLockDome().DeadLock();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private void DeadLock() &#123;</span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				// TODO Auto-generated method stub</span><br><span class="line">				synchronized (A) &#123;</span><br><span class="line">					System.out.println(&quot;获得A对象&quot;);</span><br><span class="line">					synchronized (B) &#123;</span><br><span class="line">						System.out.println(&quot;获得B对象&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				synchronized (B) &#123;</span><br><span class="line">					System.out.println(&quot;获得B对象&quot;);</span><br><span class="line">					synchronized (A) &#123;</span><br><span class="line">						System.out.println(&quot;获得A对象&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/11/%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/11/%E6%B3%9B%E5%9E%8B/" class="post-title-link" itemprop="url">泛型</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-11 15:40:12 / 修改时间：15:50:51" itemprop="dateCreated datePublished" datetime="2019-11-11T15:40:12+08:00">2019-11-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA基础</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p><strong>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</strong></p>
<p><strong>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）</strong>。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>
<h3 id="泛型的作用"><a href="#泛型的作用" class="headerlink" title="泛型的作用"></a>泛型的作用</h3><p>1，类型安全。 </p>
<pre><code>泛型的主要目标是提高 Java 程序的类型安全。编译时的强类型检查；通过知道使用泛型定义的变量的类型限制，编译器可以在一个高得多的程度上验证类型假设。没有泛型，这些假设就只存在于程序员的头脑中（或者如果幸运的话，还存在于代码注释中）。</code></pre><p>2，消除强制类型转换。 </p>
<pre><code>泛型的一个附带好处是，消除源代码中的许多强制类型转换。这使得代码更加可读，并且减少了出错机会。</code></pre><p>3，潜在的性能收益。 </p>
<pre><code>泛型为较大的优化带来可能。在泛型的初始实现中，编译器将强制类型转换（没有泛型的话，程序员会指定这些强制类型转换）插入生成的字节码中。但是更多类型信息可用于编译器这一事实，为未来版本的 JVM 的优化带来可能。由于泛型的实现方式，支持泛型（几乎）不需要 JVM 或类文件更改。所有工作都在编译器中完成，编译器生成类似于没有泛型（和强制类型转换）时所写的代码，只是更能确保类型安全而已。

 Java语言引入泛型的好处是安全简单。泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。</code></pre><p>4、更好的代码复用性，比如实现泛型算法</p>
<pre><code>在框架设计时候，BaseDao&lt;T&gt;、BaseService&lt;T&gt;、BaseDaoImpl&lt;T&gt;、BaseServiceImpl&lt;T&gt;；通过继承，实现抽象了所有公共方法，避免了每次都要写相同的代码。</code></pre><h3 id="使用泛型的注意事项"><a href="#使用泛型的注意事项" class="headerlink" title="使用泛型的注意事项"></a>使用泛型的注意事项</h3><p>1、泛型的类型参数只能是类类型（包括自定义类），不可以是简单类型。</p>
<pre><code>2、同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。

3、泛型的类型参数可以有多个。

4、泛型的参数类型可以使用extends语句，例如&lt;T extends superclass&gt;。习惯上成为“有界类型”。

5、泛型的参数类型还可以是通配符类型。例如Class&lt;?&gt; classType = Class.forName(Java.lang.String);</code></pre><h3 id="泛型的工作原理"><a href="#泛型的工作原理" class="headerlink" title="泛型的工作原理"></a>泛型的工作原理</h3><p> Java的泛型是伪泛型。在编译期间，所有的泛型信息都会被擦除掉。正确理解泛型概念的首要前提是理解类型擦出（type erasure）。</p>
<p>​       Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会在编译器在编译的时候去掉。这个过程就称为类型擦除。</p>
<p>​     如在代码中定义的List<object>和List<String>等类型，在编译后都会编程List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。</String></object></p>
<h3 id="泛型的使用方法"><a href="#泛型的使用方法" class="headerlink" title="泛型的使用方法"></a>泛型的使用方法</h3><p>（1）泛型类</p>
<p>泛型类也就是把泛型定义在类上，这样用户在使用类的时候才把类型给确定下来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectTool&lt;T&gt; &#123;</span><br><span class="line">    private T obj;</span><br><span class="line"></span><br><span class="line">    public T getObj() &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setObj(T obj) &#123;</span><br><span class="line">        this.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上面这个程序，在使用时如果定义了类型，那么在使用时就可以不用进行强制类型转换，直接就可以得到一个T类型的对象。</p>
<p>（2）泛型方法<br>有时候只关心某个方法，那么使用泛型时可以不定义泛型类，而是只定义一个泛型方法，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; void show(T t) &#123;</span><br><span class="line">       System.out.println(t);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>需要注意一下定义的格式，泛型必须得先定义才能够使用。</p>
<p>（3）继承关系<br>泛型类在继承时，可以明确父类（泛型类）的参数类型，也可以不明确。<br>现在我们有如下的泛型类<br>//泛型类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Inter&lt;T&gt; &#123;</span><br><span class="line">    public abstract void show(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>①明确类型<br>//在实现泛型类时明确父类的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class InterImpl implements Inter&lt;String&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show(String s) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②不明确类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class InterImpl&lt;T&gt; implements Inter&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void show(T t) &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/10/%E8%BE%93%E5%85%A5url%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wingkywingky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sagittarius">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/10/%E8%BE%93%E5%85%A5url%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/" class="post-title-link" itemprop="url">输入url发生什么</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-10 22:44:47 / 修改时间：22:51:33" itemprop="dateCreated datePublished" datetime="2019-11-10T22:44:47+08:00">2019-11-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>从开发&amp;运维角度方面来看，总体来说分为以下几个过程</p>
<ul>
<li>查找浏览器缓存</li>
<li>DNS 解析:将域名解析成 IP 地址</li>
<li>TCP 连接：TCP 三次握手</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>断开连接：TCP 四次挥手</li>
</ul>
<p>首先我们需要知道TCP/IP的网络模型，这里我就以四层模型为例子。</p>
<p>。</p>
<p><img src="http://images0.cnblogs.com/blog/622045/201507/020946547655321.png" alt="这里写图片描述"></p>
<p>第一步：在浏览器中输入<a href="http://www.baidu.com后，应用层会使用DNS解析域名，如果本地存有对应的IP，则使用；如果没有，则会向上级DNS服务器请求帮助，直至获得IP。域名解析详细过程会在下文讲到。" target="_blank" rel="noopener">www.baidu.com后，应用层会使用DNS解析域名，如果本地存有对应的IP，则使用；如果没有，则会向上级DNS服务器请求帮助，直至获得IP。域名解析详细过程会在下文讲到。</a></p>
<p>第二步：应用层将请求的信息装载入HTTP请求报文，信息包含了请求的方法（GET / POST）、目标url、遵循的协议（http / https / ftp…）等，然后应用层将发起HTTP请求。</p>
<p>第三步：传输层接收到应用层传递下来的数据，并分割成以报文段为单位的数据包进行管理，并为它们编号，方便服务器接收时能准确地还原报文信息。通过三次握手和目标端口建立安全通信。</p>
<p>第四步：网络层接收传输层传递的数据，根据IP通过ARP协议获得目标计算机物理地址—MAC。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标。</p>
<p>第五步：找到目标MAC地址以后，就将数据发送到数据链路层，这时开始真正的传输请求信息，传输完成以后请求结束。</p>
<p>第六步：服务器接收数据后，从下到上层层将数据解包，直到应用层。</p>
<p>第七步： 服务器接收到客户端发送的HTTP请求后，查找客户端请求的资源，将数据装载入响应报文并返回，响应报文中包括一个重要的信息——状态码，如200,404,500。<br>————————————————<br>版权声明：本文为CSDN博主「早就戒了」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_37169817/article/details/78663598" target="_blank" rel="noopener">https://blog.csdn.net/qq_37169817/article/details/78663598</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="wingkywingky"
    src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">wingkywingky</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wingkywingky</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  
















  

  

</body>
</html>
